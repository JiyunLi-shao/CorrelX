<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>msvf &#8212; CorrelX 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for msvf</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># &lt;nbformat&gt;3.0&lt;/nbformat&gt;</span>

<span class="c1"># &lt;codecell&gt;</span>

<span class="c1">#!/usr/bin/env python</span>
<span class="c1">#</span>
<span class="c1">#The MIT CorrelX Correlator</span>
<span class="c1">#</span>
<span class="c1">#https://github.com/MITHaystack/CorrelX</span>
<span class="c1">#Contact: correlX@haystack.mit.edu</span>
<span class="c1">#Project leads: Victor Pankratius, Pedro Elosegui Project developer: A.J. Vazquez Alvarez</span>
<span class="c1">#</span>
<span class="c1">#Copyright 2017 MIT Haystack Observatory</span>
<span class="c1">#</span>
<span class="c1">#Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</span>
<span class="c1">#</span>
<span class="c1">#The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</span>
<span class="c1">#</span>
<span class="c1">#THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#------------------------------</span>
<span class="c1">#------------------------------</span>
<span class="c1">#Project: CorrelX.</span>
<span class="c1">#File: msvf.py.</span>
<span class="c1">#Author: A.J. Vazquez Alvarez (ajvazquez@haystack.mit.edu)</span>
<span class="c1">#Description: </span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Mapper: reads VDIF frames from std.input and generates one mapreduce line per band per frame.</span>

<span class="sd">Parameters</span>
<span class="sd">----------</span>
<span class="sd"> See lib_mapredcorr.get_mapper_params_str()</span>
<span class="sd">    </span>
<span class="sd">Returns</span>
<span class="sd">-------</span>
<span class="sd"> See msvf.get_pair_str()</span>
<span class="sd">    </span>
<span class="sd">Notes</span>
<span class="sd">-----</span>
<span class="sd">|</span>
<span class="sd">| **Reader:**</span>
<span class="sd">|</span>
<span class="sd">|  See msvf.read_frame()</span>
<span class="sd">|</span>
<span class="sd">|</span>
<span class="sd">| **Configuration:**</span>
<span class="sd">|</span>
<span class="sd">|  See const_mapred.py</span>
<span class="sd">|</span>
<span class="sd">|</span>
<span class="sd">| **Debugging:**</span>
<span class="sd">|</span>
<span class="sd">|  See const_debug.py</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#History:</span>
<span class="c1">#initial version: 2015.12 ajva</span>
<span class="c1">#MIT Haystack Observatory</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span><span class="n">division</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">base64</span>
<span class="kn">import</span> <span class="nn">imp</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.fftpack</span>

<span class="c1"># Library for reading VDIF files</span>
<span class="kn">import</span> <span class="nn">lib_vdif</span>
<span class="n">imp</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="n">lib_vdif</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">lib_vdif</span> <span class="k">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">lib_pcal</span>
<span class="n">imp</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="n">lib_pcal</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">lib_pcal</span> <span class="k">import</span> <span class="o">*</span>

<span class="c1"># Basic (de)quantizer</span>
<span class="c1"># TO DO: use newer implementation for dequantizer</span>
<span class="kn">import</span> <span class="nn">lib_quant</span>
<span class="n">imp</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="n">lib_quant</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">lib_quant</span> <span class="k">import</span> <span class="o">*</span>

<span class="c1"># (De)serializer for info on scenario</span>
<span class="kn">import</span> <span class="nn">lib_ini_files</span>
<span class="n">imp</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="n">lib_ini_files</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">lib_ini_files</span> <span class="k">import</span> <span class="o">*</span>

<span class="c1"># Vector quantization                           # VQ disabled</span>
<span class="c1">#import lib_vq</span>
<span class="c1">#imp.reload(lib_vq)</span>
<span class="c1">#from lib_vq import *</span>

<span class="c1"># Constants for mapper and reducer</span>
<span class="kn">import</span> <span class="nn">const_mapred</span>
<span class="n">imp</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="n">const_mapred</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">const_mapred</span> <span class="k">import</span> <span class="o">*</span>

<span class="c1"># Constants for performance</span>
<span class="kn">import</span> <span class="nn">const_performance</span>
<span class="n">imp</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="n">const_performance</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">const_performance</span> <span class="k">import</span> <span class="o">*</span>

<span class="c1">#from bitarray import bitarray</span>

<span class="kn">import</span> <span class="nn">lib_acc_comp</span>
<span class="n">imp</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="n">lib_acc_comp</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">lib_acc_comp</span> <span class="k">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">lib_delay_model</span>
<span class="n">imp</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="n">lib_delay_model</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">lib_delay_model</span> <span class="k">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">lib_debug</span>
<span class="n">imp</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="n">lib_debug</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">lib_debug</span> <span class="k">import</span> <span class="o">*</span>





<span class="c1"># TO DO: bring debug flags to configuration file</span>
<span class="c1"># TO DO: define constants for &quot;zM&quot; and &quot;zR&quot;</span>




<span class="c1">###########################################</span>
<span class="c1">#           Haddop environmet variables</span>
<span class="c1">###########################################</span>


<div class="viewcode-block" id="get_current_filename"><a class="viewcode-back" href="../msvf.html#msvf.get_current_filename">[docs]</a><span class="k">def</span> <span class="nf">get_current_filename</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the name of the file currently being processed from the environment variable.</span>
<span class="sd">    Note this is only for hadoop, thus the variable has to be created if running in pipeline, (which</span>
<span class="sd">        is already done in lib_mapredcorr.py.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">file_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">MAP_INPUT_FILE</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">file_name</span><span class="o">!=</span><span class="s2">&quot;None&quot;</span><span class="p">:</span>
        <span class="n">file_name</span><span class="o">=</span><span class="n">file_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span></div>



<span class="c1">###########################################</span>
<span class="c1">#           MapReduce key management</span>
<span class="c1">###########################################</span>



<div class="viewcode-block" id="get_pair_str"><a class="viewcode-back" href="../msvf.html#msvf.get_pair_str">[docs]</a><span class="k">def</span> <span class="nf">get_pair_str</span><span class="p">(</span><span class="n">char_p</span><span class="p">,</span><span class="n">pair</span><span class="p">,</span><span class="n">accu_block</span><span class="p">,</span><span class="n">mod_channel</span><span class="p">,</span><span class="n">num_channels</span><span class="p">,</span><span class="n">seconds_fr</span><span class="p">,</span><span class="n">first_sample_signal</span><span class="p">,</span><span class="n">station_id</span><span class="p">,</span>\
                 <span class="n">mod_polarization_id</span><span class="p">,</span><span class="n">freq_sample</span><span class="p">,</span><span class="n">bits_per_sample</span><span class="p">,</span><span class="n">data_type_char</span><span class="p">,</span><span class="n">encoding</span><span class="p">,</span>\
                 <span class="n">n_bins_pcal_val</span><span class="p">,</span><span class="n">pcal_freq</span><span class="p">,</span><span class="n">one_baseline_per_task</span><span class="p">,</span><span class="n">task_scaling_stations</span><span class="p">,</span>\
                 <span class="n">id_pair</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">tot_pairs</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">tot_accu_blocks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">num_samples</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">abs_delay</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">rate_delay</span><span class="o">=</span><span class="p">[],</span>\
                 <span class="n">freq_channel</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">fractional_sample_delay</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">accumulation_time</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">shift_int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">sideband</span><span class="o">=</span><span class="s2">&quot;L&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build output string with key and first part of value (metadata) for map output.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     char_p : char {&#39;x&#39;,&#39;r&#39;,&#39;y&#39;}</span>
<span class="sd">         identifies the mode of operation:</span>
<span class="sd">            |       &#39;x&#39; for all-baselines-per-task,</span>
<span class="sd">            |       &#39;r&#39; for linear scaling with the number of stations,</span>
<span class="sd">            |       &#39;y&#39; for one-baseline-per-task.</span>
<span class="sd">     pair : str</span>
<span class="sd">         A.A-A.A for all-baselines-per-task, station0.polarization0-station1.polarization1 for single-baseline-per-task.</span>
<span class="sd">     accu_block : int</span>
<span class="sd">         accumulation period id.</span>
<span class="sd">     mod_channel : int</span>
<span class="sd">         channel id.</span>
<span class="sd">     num_channels : int</span>
<span class="sd">         number of channels.</span>
<span class="sd">     seconds_fr : int</span>
<span class="sd">         [repeated] currently same as accu_block.</span>
<span class="sd">     first_sample_signal : int</span>
<span class="sd">         sample number for the first sample in this chunk of samples.</span>
<span class="sd">     station_id : int</span>
<span class="sd">         station identifier corresponding to this chunk of samples.</span>
<span class="sd">     mod_polarization_id : int</span>
<span class="sd">         polarization identifier corresponding to this chunk of samples.</span>
<span class="sd">     freq_sample : int</span>
<span class="sd">         sampling frequency [Hz].</span>
<span class="sd">     bits_per_sample : int</span>
<span class="sd">         number of bits per sample component.</span>
<span class="sd">     data_type_char : char {&#39;r&#39;,&#39;c&#39;}</span>
<span class="sd">         &#39;r&#39; for real, &#39;c&#39; for complex.</span>
<span class="sd">     encoding : str</span>
<span class="sd">         type of encoding compression used (C_INI_MEDIA_C_*).</span>
<span class="sd">     n_bins_pcal_val : int</span>
<span class="sd">         number of bins for the phase calibration window.</span>
<span class="sd">     pcal_freq : int</span>
<span class="sd">         phase calibration tone separation [Hz].</span>
<span class="sd">     one_baseline_per_task : int</span>
<span class="sd">         [default 0], 1 for one baseline per task (work in progress)</span>
<span class="sd">     task_scaling_stations : int</span>
<span class="sd">         [default 0], 1 for linear scaling with stations (work in progress)</span>
<span class="sd">     id_pair</span>
<span class="sd">         [only used if one_baseline_per_task==1]</span>
<span class="sd">     tot_pairs </span>
<span class="sd">         [currently unused, but should be used if one-baseline-per-task]</span>
<span class="sd">     tot_accu_blocks : int</span>
<span class="sd">         number of accumulation periods in the scan.</span>
<span class="sd">     num_samples : int</span>
<span class="sd">         number of samples in this chunk (required in reducer in case last bytes not filled with samples).</span>
<span class="sd">     abs_delay : float</span>
<span class="sd">         absolute delay for this chunk.</span>
<span class="sd">     rate_delay : list</span>
<span class="sd">         list with delay polynomials (see get_absolute_delay()).</span>
<span class="sd">     freq_channel : float</span>
<span class="sd">         edge frequency [Hz] corresponding to the samples in this chunk.</span>
<span class="sd">     fractional_sample_delay : float</span>
<span class="sd">         fractional sample delay for the first sample in this chunk.</span>
<span class="sd">     accumulation_time : float</span>
<span class="sd">         accumulation period duration [s].</span>
<span class="sd">     shift_int : int</span>
<span class="sd">         number of sample components used to offset these samples (integer delay).</span>
<span class="sd">     sideband : char {&#39;L&#39;,&#39;U&#39;}</span>
<span class="sd">         &#39;L&#39; for lower-sideband &#39;U&#39; for upper-sideband.  </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     pair_str : str</span>
<span class="sd">         complete header for the current set of samples being processed.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    |</span>
<span class="sd">    | **Output formatting and conventions:**</span>
<span class="sd">    |</span>
<span class="sd">    |  The fields in the key below (k1,k2,...) separated by FIELD_SEP are referenced in const_mapred.py for the sorting configuration.</span>
<span class="sd">    |   The metadata must follow the same order as defined in const_mapred.py.</span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **Notes:**</span>
<span class="sd">    |</span>
<span class="sd">    |  The full output corresponds to the output string generated here and the samples packed in base64 (done outside).</span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **TO DO:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Simplify interface.</span>
<span class="sd">    |  seconds_fr, delete and take accu block... </span>
<span class="sd">    |  Define constants for real and complex chars, and for lower and upper sideband.</span>
<span class="sd">    |  Define constant for initial &quot;p&quot; in line, initially for pair.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Num channels spec : number of channels specified in ini file, used for partitioning</span>
    <span class="c1">#char_p=&quot;x&quot;</span>
    <span class="c1">## Check indices LSB</span>
    <span class="c1">#pcal_ind_row=pcal_ind_row[pcal_ind_row&gt;(-1*n_bins_pcal_val)]</span>
    <span class="c1">## Check indices USB</span>
    <span class="c1">#pcal_ind_row=pcal_ind_row[pcal_ind_row&lt;(n_bins_pcal_val)]</span>
    
    <span class="c1">#If not autocorr do not print pcal info</span>
    <span class="k">if</span> <span class="n">one_baseline_per_task</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">((</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">pair</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="ow">and</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">pair</span><span class="p">[</span><span class="mi">3</span><span class="p">])):</span>
            <span class="c1">#pcal_ind_row=[0]</span>
            <span class="c1"># TO DO: n_bins_pcal_val ?</span>
            <span class="c1">#n_bins_pcal=0</span>
            <span class="n">pcal_freq</span><span class="o">=</span><span class="mi">0</span>
            

    
    <span class="c1"># Using this key for full control on the partitioning (one key for reducer...)</span>
    <span class="n">key_value</span><span class="o">=</span><span class="n">accu_block</span><span class="o">*</span><span class="n">num_channels</span><span class="o">+</span><span class="n">mod_channel</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">one_baseline_per_task</span><span class="p">)</span><span class="ow">or</span><span class="p">(</span><span class="n">task_scaling_stations</span><span class="p">):</span>
        <span class="n">key_value</span><span class="o">=</span><span class="n">id_pair</span><span class="o">*</span><span class="n">tot_accu_blocks</span><span class="o">*</span><span class="n">num_channels</span><span class="o">+</span><span class="n">key_value</span>
    
    <span class="n">first_sample_signal</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">first_sample_signal</span><span class="p">)</span>
    
    <span class="c1"># Station polarization</span>
    <span class="n">st_pol</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">station_id</span><span class="p">)</span> <span class="o">+</span> <span class="n">SF_SEP</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mod_polarization_id</span><span class="p">)</span>
    
    <span class="c1"># Delay information (lib_ini_files.get_rates_cache())</span>
    <span class="p">[</span><span class="n">delay_rate_0</span><span class="p">,</span>\
     <span class="n">delay_rate_1</span><span class="p">,</span>\
     <span class="n">delay_rate_2</span><span class="p">,</span>\
     <span class="n">delay_rate_ref</span><span class="p">,</span>\
     <span class="n">clock_rate_0</span><span class="p">,</span>\
     <span class="n">clock_rate_1</span><span class="p">,</span>\
     <span class="n">clock_abs_rate_0</span><span class="p">,</span>\
     <span class="n">clock_abs_rate_1</span><span class="p">,</span>\
     <span class="n">clock_rate_ref</span><span class="p">,</span>\
     <span class="n">model_only_delay</span><span class="p">,</span>\
     <span class="n">clock_only_delay</span><span class="p">,</span>\
     <span class="n">diff_frac</span><span class="p">]</span> <span class="o">=</span> <span class="n">rate_delay</span>
    
    <span class="c1"># Following format from const_mapred.py</span>
    <span class="n">metadata_v</span> <span class="o">=</span> <span class="p">[</span><span class="n">st_pol</span><span class="p">,</span>\
                  <span class="n">shift_int</span><span class="p">,</span>\
                  <span class="n">fractional_sample_delay</span><span class="p">,</span>\
                  <span class="n">abs_delay</span><span class="p">,</span>\
                  <span class="n">delay_rate_0</span><span class="p">,</span>\
                  <span class="n">delay_rate_1</span><span class="p">,</span>\
                  <span class="n">delay_rate_2</span><span class="p">,</span>\
                  <span class="n">delay_rate_ref</span><span class="p">,</span>\
                  <span class="n">clock_rate_0</span><span class="p">,</span>\
                  <span class="n">clock_rate_1</span><span class="p">,</span>\
                  <span class="n">clock_abs_rate_0</span><span class="p">,</span>\
                  <span class="n">clock_abs_rate_1</span><span class="p">,</span>\
                  <span class="n">clock_rate_ref</span><span class="p">,</span>\
                  <span class="n">model_only_delay</span><span class="p">,</span>\
                  <span class="n">clock_only_delay</span><span class="p">,</span>\
                  <span class="n">diff_frac</span><span class="p">,</span>\
                  <span class="n">num_samples</span><span class="p">,</span>\
                  <span class="n">freq_sample</span><span class="p">,</span>\
                  <span class="n">bits_per_sample</span><span class="p">,</span>\
                  <span class="n">first_sample_signal</span><span class="p">,</span>\
                  <span class="n">data_type_char</span><span class="p">,</span>\
                  <span class="n">n_bins_pcal_val</span><span class="p">,</span>\
                  <span class="n">pcal_freq</span><span class="p">,</span>\
                  <span class="n">mod_channel</span><span class="p">,</span>\
                  <span class="n">freq_channel</span><span class="p">,</span>\
                  <span class="n">accumulation_time</span><span class="p">,</span>\
                  <span class="n">encoding</span><span class="p">,</span>\
                  <span class="n">sideband</span><span class="p">]</span>
    
    
    <span class="c1"># Generation of KEY and VALUE in the same line</span>
    <span class="c1">#  FIELD_SEP: field separator</span>
    <span class="c1">#  SF_SEP:    sub-field separator</span>
    <span class="c1"># TO DO: define constant for hard-coded chars</span>
    <span class="c1">#                                                                           KEY</span>
    <span class="c1">#                                                                               Mode of operation         [k1]</span>
    <span class="n">pair_str</span> <span class="o">=</span>  <span class="s2">&quot;p&quot;</span><span class="o">+</span><span class="n">char_p</span>
    <span class="c1">#                                                                               Baseline (or all)         [k2,k3]</span>
    <span class="n">pair_str</span> <span class="o">+=</span>     <span class="n">FIELD_SEP</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">SF_SEP</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span>\
                    <span class="n">FIELD_SEP</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="n">SF_SEP</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">+</span><span class="n">FIELD_SEP</span>
    <span class="c1">#                                                                               Accumulation              [k4,k5,k6,k7]</span>
    <span class="n">pair_str</span> <span class="o">+=</span> <span class="s2">&quot;a&quot;</span><span class="o">+</span><span class="n">FIELD_SEP</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">key_value</span><span class="p">)</span><span class="o">+</span>\
                    <span class="n">FIELD_SEP</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">accu_block</span><span class="p">)</span><span class="o">+</span>\
                    <span class="n">FIELD_SEP</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">mod_channel</span><span class="p">)</span>
    <span class="c1">#                                                                               First sample id.          [k8]</span>
    <span class="n">pair_str</span> <span class="o">+=</span>     <span class="n">FIELD_SEP</span><span class="o">+</span><span class="s2">&quot;f&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">seconds_fr</span><span class="p">)</span><span class="o">+</span>\
                       <span class="n">SF_SEP</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">first_sample_signal</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="n">PAD_S</span><span class="p">)</span><span class="o">+</span>\
                       <span class="n">SF_SEP</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">mod_channel</span><span class="p">)</span>
    <span class="c1">#                                                                               Station id.               [k9]</span>
    <span class="n">pair_str</span> <span class="o">+=</span>     <span class="n">FIELD_SEP</span><span class="o">+</span><span class="s2">&quot;s&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">station_id</span><span class="p">)</span><span class="o">+</span>\
                       <span class="n">SF_SEP</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">mod_polarization_id</span><span class="p">)</span>
    <span class="c1">#                                                                           SEPARATOR between key and value</span>
    <span class="n">pair_str</span> <span class="o">+=</span>     <span class="n">FIELD_SEP</span><span class="o">+</span><span class="n">KEY_SEP</span>
    <span class="c1">#                                                                           VALUE</span>
    <span class="n">pair_str</span><span class="o">+=</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="n">metadata_v</span><span class="p">))</span>
    <span class="c1">#                                                                                Metadata</span>
    <span class="n">pair_str</span><span class="o">+=</span><span class="s2">&quot; &quot;</span>
    <span class="c1">#                                                                                (Samples added outside)</span>
    
    <span class="k">return</span><span class="p">(</span><span class="n">pair_str</span><span class="p">)</span>                       </div>
                                



<div class="viewcode-block" id="calculate_corr_pairs_one_baseline_per_task"><a class="viewcode-back" href="../msvf.html#msvf.calculate_corr_pairs_one_baseline_per_task">[docs]</a><span class="k">def</span> <span class="nf">calculate_corr_pairs_one_baseline_per_task</span><span class="p">(</span><span class="n">tot_stations</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">tot_pols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">auto_stations</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">auto_pols</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create array with identificators for all the correlation pairs for all the stations p&lt;station_i&gt;&lt;station_j&gt;.</span>
<span class="sd">    </span>
<span class="sd">    Only used in one-baseline-per-task mode.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     tot_stations : int</span>
<span class="sd">         number of stations.</span>
<span class="sd">     tot_pols : int</span>
<span class="sd">         number of polarizations</span>
<span class="sd">     auto_stations : int</span>
<span class="sd">         |   0 : only different stations (default)</span>
<span class="sd">         |   1 : allow same station</span>
<span class="sd">         |   2 : only same station</span>
<span class="sd">     auto_pols : int</span>
<span class="sd">         |   0 : only different polarizations</span>
<span class="sd">         |   1 : allow same polarization (default)</span>
<span class="sd">         |   2 : only same polarization</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     pairs_list : list of lists [station_a,polarization_a,station_b,polarization_b]</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    |</span>
<span class="sd">    | **Limitations:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Currently assuming that all the stations have the same number of polarizations.</span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **TO DO:**</span>
<span class="sd">    |</span>
<span class="sd">    |  This is only used in one-baseline-per-task mode, but still called from main and used in logging.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">pairs_list</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">s0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">tot_stations</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s0</span><span class="p">,</span><span class="n">tot_stations</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">tot_pols</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">t1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">tot_pols</span><span class="p">):</span>
                    
                    <span class="c1"># Stations (note use of &lt; instead of != to avoid generating duplicates)</span>
                    <span class="k">if</span> <span class="n">auto_stations</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># Only different stations</span>
                        <span class="n">condition_station</span><span class="o">=</span><span class="p">(</span><span class="n">s0</span><span class="o">&lt;</span><span class="n">s1</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">auto_stations</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># Allow same station</span>
                        <span class="c1">#condition_station=(s0&lt;=s1)</span>
                        <span class="n">condition_station</span><span class="o">=</span><span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span> <span class="c1">#auto_stations==2:</span>
                        <span class="c1"># Only same station</span>
                        <span class="n">condition_station</span><span class="o">=</span><span class="p">(</span><span class="n">s0</span><span class="o">==</span><span class="n">s1</span><span class="p">)</span>
                    
                    <span class="c1"># Polarizations</span>
                    <span class="c1">#if auto_pols==0:</span>
                    <span class="c1">#    # Only different polarizations</span>
                    <span class="c1">#    condition_pols=(t0!=t1)</span>
                    <span class="c1">#elif auto_pols==1:</span>
                    <span class="k">if</span> <span class="n">auto_pols</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># Allow same thread</span>
                        <span class="c1">#condition_thread=True</span>
                        <span class="n">condition_thread</span><span class="o">=</span><span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span> <span class="c1">#auto_pols==2:</span>
                        <span class="c1"># Only same thread (e.g. if threads are bands)</span>
                        <span class="n">condition_thread</span><span class="o">=</span><span class="p">(</span><span class="n">t0</span><span class="o">==</span><span class="n">t1</span><span class="p">)</span>
                    
                    <span class="c1"># Generate correlation pairs based on previous conditions</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">condition_station</span><span class="p">)</span><span class="ow">and</span><span class="p">(</span><span class="n">condition_thread</span><span class="p">):</span>
                        <span class="c1"># avoid duplicates (switching pairs location)</span>
                        <span class="c1">#if [s1,t1,s0,t0] not in pairs_list:</span>
                        <span class="c1"># TO DO: check this</span>
                        <span class="k">if</span> <span class="ow">not</span><span class="p">((</span><span class="n">s0</span><span class="o">==</span><span class="n">s1</span><span class="p">)</span><span class="ow">and</span><span class="p">(</span><span class="n">t0</span><span class="o">&gt;</span><span class="n">t1</span><span class="p">)):</span>
                            <span class="n">pairs_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">s0</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">t1</span><span class="p">])</span>
                        <span class="c1">#if (condition_thread==(s0==s1))and(t0!=t0):</span>
                        <span class="c1">#    pairs_list.append([s0,t1,s1,t0])</span>
    <span class="k">return</span><span class="p">(</span><span class="n">pairs_list</span><span class="p">)</span></div>




<div class="viewcode-block" id="get_pair_all_baselines_per_task"><a class="viewcode-back" href="../msvf.html#msvf.get_pair_all_baselines_per_task">[docs]</a><span class="k">def</span> <span class="nf">get_pair_all_baselines_per_task</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get pair for all baselines per tasks.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pair</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="s2">&quot;A&quot;</span><span class="p">]</span>
    <span class="k">return</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_pair_linear_scaling"><a class="viewcode-back" href="../msvf.html#msvf.get_pair_linear_scaling">[docs]</a><span class="k">def</span> <span class="nf">get_pair_linear_scaling</span><span class="p">(</span><span class="n">s0</span><span class="p">,</span><span class="n">t0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get pair for linear scaling with number of stations.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     s0 : int</span>
<span class="sd">         station id</span>
<span class="sd">     t0 : int</span>
<span class="sd">         polarization id</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pair</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">s0</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="n">t0</span><span class="p">),</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="s2">&quot;A&quot;</span><span class="p">]</span>
    <span class="k">return</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_alloc_tasks_linear_scaling"><a class="viewcode-back" href="../msvf.html#msvf.get_alloc_tasks_linear_scaling">[docs]</a><span class="k">def</span> <span class="nf">get_alloc_tasks_linear_scaling</span><span class="p">(</span><span class="n">num_pairs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get allocation of stations into tasks. It computes the matrix that defines which pairs are associated to each task.</span>
<span class="sd">    Only used in station-based-splitting (linear scaling with number of stations).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     num_pairs : int</span>
<span class="sd">         number of pairs.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     a : binary 2D square array</span>
<span class="sd">         task allocation.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    |</span>
<span class="sd">    | **TODO:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Detail the algorithm.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">num_pairs</span><span class="p">,</span><span class="n">num_pairs</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">num_pairs</span><span class="o">/</span><span class="mi">2</span><span class="p">))):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_pairs</span><span class="o">-</span><span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">num_pairs</span><span class="p">:</span>
                <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
    <span class="k">return</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></div>





<span class="c1">###########################################</span>
<span class="c1">#           Input reader</span>
<span class="c1">###########################################</span>


<div class="viewcode-block" id="read_frame"><a class="viewcode-back" href="../msvf.html#msvf.read_frame">[docs]</a><span class="k">def</span> <span class="nf">read_frame</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span><span class="n">show_errors</span><span class="p">,</span><span class="n">forced_frame_length</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">forced_format</span><span class="o">=</span><span class="n">C_INI_MEDIA_F_VDIF</span><span class="p">,</span><span class="n">forced_version</span><span class="o">=</span><span class="n">C_INI_MEDIA_V_CUSTOM</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It returns the header and samples in the frame, based on the information from the media.ini file. If this information</span>
<span class="sd">    is not available then it assumes that it is a vdif frame.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     reader : file handle</span>
<span class="sd">         sys.stdin.</span>
<span class="sd">     show_errors : int</span>
<span class="sd">         [0 by default] 1 for verbose mode.</span>
<span class="sd">     forced_frame_length : int</span>
<span class="sd">         [0 by default] &gt;0 to force the number of bytes per frame (if ==0 frame length is read in header)</span>
<span class="sd">     forced_format</span>
<span class="sd">         [leave deafult value] use only for new implementations of readers.</span>
<span class="sd">     forced_version</span>
<span class="sd">         [leave deafult value] use only for new implementations of readers.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     header : list</span>
<span class="sd">         frame header following the format: </span>
<span class="sd">           |     [seconds_frame,invalid_marker,legacy_marker,reference_epoch,frame_number,</span>
<span class="sd">           |     vdif_version,log_2_channels,frame_length,data_type,bits_per_sample,thread_id,station_id] where:</span>
<span class="sd">           |          seconds_frame:     integer value with seconds for this frame.</span>
<span class="sd">           |          invalid_marker:    VDIF invalid bit.</span>
<span class="sd">           |          legacy_marker:     VDIF legacy bit.</span>
<span class="sd">           |          reference_epoch:   VDIF frame epoch (float with MJD (TBC)).</span>
<span class="sd">           |          frame_number:      VDIF frame number (integer).</span>
<span class="sd">           |          vdif_version:      VDIF frame version (integer).</span>
<span class="sd">           |          log_2_channels:    VDIF logarithm in base 2 of the number of channels in the frame.</span>
<span class="sd">           |          frame_length:      VDIF frame length (integer with number of bytes).</span>
<span class="sd">           |          data_type:         VDIF frame data type bit.</span>
<span class="sd">           |          bits_per_sample:   number of bits per sample.</span>
<span class="sd">           |          thread_id:         VDIF thread identifier field (integer).</span>
<span class="sd">           |          station_id:        VDIF station id field (integer).</span>
<span class="sd">     allsamples : 1d numpy array of int</span>
<span class="sd">         sample components (see below for details).</span>
<span class="sd">     check_size_samples : int</span>
<span class="sd">         1 if read as many samples as expected from the frame length (and rest of metadata), 0 otherwise.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    |</span>
<span class="sd">    | **Adding new libraries:**</span>
<span class="sd">    |</span>
<span class="sd">    |  -Each library will be identified by &quot;format&quot; and &quot;version&quot;, to be specified in the media.ini file.</span>
<span class="sd">    |  -Add the new format and version into const_ini_media.py</span>
<span class="sd">    |  -Add the check for new format in the if structure below (if forced format==...)</span>
<span class="sd">    |  -See the definition of the header to be returned above.</span>
<span class="sd">    |  -The samples should be in a 1D numpy array of integers. E.g. for VDIF complex frame, [I0, Q0, I1, Q1, ...]</span>
<span class="sd">    |  -The implementation is currently tied to the VDIF format, so samples corresponding to different channels will be interleaved.</span>
<span class="sd">    |  -If multiple bands or polarizations per file see VDIF specification (multiple thread or multiple channels).</span>
<span class="sd">    |  -If simple case with single band and single polarization then log_2_channels=0 and thread_id=0 (and configure media.ini accordingly)</span>
<span class="sd">    |  -See lib_vdif.py for more info.</span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **TO DO:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Consider providing a general interface to allow easy development of new libraries.</span>
<span class="sd">    |  use_ini_info always used, remove option.</span>
<span class="sd">    |  forced_frame_length is not taken into account, remove it (length is read in the VDIF frame).</span>
<span class="sd">    |  Remove option for bitarray_structures, no longer used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check_size_samples</span> <span class="o">=</span> <span class="mi">0</span>
    
    
    <span class="n">header</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">allsamples</span><span class="o">=</span><span class="p">[]</span>
    
    <span class="n">other_cases</span><span class="o">=</span><span class="mi">1</span>
    <span class="c1"># VDIF</span>
    <span class="k">if</span> <span class="n">forced_format</span> <span class="o">==</span> <span class="n">C_INI_MEDIA_F_VDIF</span><span class="p">:</span>
        <span class="c1"># (custom version)</span>
        <span class="k">if</span> <span class="n">forced_version</span> <span class="o">==</span> <span class="n">C_INI_MEDIA_V_CUSTOM</span><span class="p">:</span>
            <span class="p">[</span><span class="n">header</span><span class="p">,</span><span class="n">allsamples</span><span class="p">,</span><span class="n">check_size_samples</span><span class="p">]</span> <span class="o">=</span> <span class="n">lib_vdif</span><span class="o">.</span><span class="n">read_vdif_frame</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">reader</span><span class="p">,</span><span class="n">show_errors</span><span class="o">=</span><span class="n">show_errors</span><span class="p">,</span><span class="n">forced_frame_length</span><span class="o">=</span><span class="n">forced_frame_length</span><span class="p">,</span><span class="n">v</span><span class="o">=</span><span class="n">VERBOSE_MAPPER_IO</span><span class="p">)</span>
            <span class="n">other_cases</span><span class="o">=</span><span class="mi">0</span>
    
    <span class="c1"># Other cases: f,show_errors=0,forced_frame_length=0,offset_bytes=0,encode_int=0</span>
    <span class="k">if</span> <span class="n">other_cases</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="p">[</span><span class="n">header</span><span class="p">,</span><span class="n">allsamples</span><span class="p">,</span><span class="n">check_size_samples</span><span class="p">]</span> <span class="o">=</span> <span class="n">lib_vdif</span><span class="o">.</span><span class="n">read_vdif_frame</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">reader</span><span class="p">,</span><span class="n">show_errors</span><span class="o">=</span><span class="n">show_errors</span><span class="p">,</span><span class="n">forced_frame_length</span><span class="o">=</span><span class="n">forced_frame_length</span><span class="p">,</span><span class="n">v</span><span class="o">=</span><span class="n">VERBOSE_MAPPER_IO</span><span class="p">)</span>
    
    
    <span class="k">return</span><span class="p">([</span><span class="n">header</span><span class="p">,</span><span class="n">allsamples</span><span class="p">,</span><span class="n">check_size_samples</span><span class="p">])</span></div>




<span class="c1">###########################################</span>
<span class="c1">#      Delay/offsets/samples management</span>
<span class="c1">###########################################</span>



<div class="viewcode-block" id="get_num_samples_per_frame"><a class="viewcode-back" href="../msvf.html#msvf.get_num_samples_per_frame">[docs]</a><span class="k">def</span> <span class="nf">get_num_samples_per_frame</span><span class="p">(</span><span class="n">allsamples</span><span class="p">,</span><span class="n">num_channels</span><span class="p">,</span><span class="n">data_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Based on number of channels and data type (complex or real, get number of samples per frame.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     allsamples : int</span>
<span class="sd">         total number of sample components in the frame.</span>
<span class="sd">     num_channels : int</span>
<span class="sd">         number of channels in the frame.</span>
<span class="sd">     data_type : int</span>
<span class="sd">         0 for real, 1 for complex.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     tot_samples_per_channel_and_frame_full : int</span>
<span class="sd">         number of samples per channel per frame (full samples, i.e. R or R+jI)</span>
<span class="sd">     totsamples_per_channel_and_frame_single : int</span>
<span class="sd">         number of sample components (i.e. R, I).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tot_samples_per_channel_and_frame</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">allsamples</span><span class="p">)</span><span class="o">//</span><span class="n">num_channels</span>
    <span class="c1"># number of full samples (real and imag for complex)</span>
    <span class="k">if</span> <span class="n">data_type</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">tot_samples_per_channel_and_frame_full</span><span class="o">=</span><span class="n">tot_samples_per_channel_and_frame</span><span class="o">//</span><span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tot_samples_per_channel_and_frame_full</span><span class="o">=</span><span class="n">tot_samples_per_channel_and_frame</span>
    
    <span class="k">return</span><span class="p">([</span><span class="n">tot_samples_per_channel_and_frame</span><span class="p">,</span><span class="n">tot_samples_per_channel_and_frame_full</span><span class="p">])</span></div>







<div class="viewcode-block" id="check_time_frame"><a class="viewcode-back" href="../msvf.html#msvf.check_time_frame">[docs]</a><span class="k">def</span> <span class="nf">check_time_frame</span><span class="p">(</span><span class="n">accu_block</span><span class="p">,</span><span class="n">rel_pos_frame</span><span class="p">,</span><span class="n">actual_frame_time</span><span class="p">,</span><span class="n">seconds_ref</span><span class="p">,</span><span class="n">seconds_duration</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if actual timestamp of this frame is inside the experiment time wnidow.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     accu_block</span>
<span class="sd">         accumulation period id (-1 if outside scan window).</span>
<span class="sd">     rel_pos_frame</span>
<span class="sd">         relative frame position in accumulation period.</span>
<span class="sd">     actual_frame_time</span>
<span class="sd">         actual timestamp (considering delays) for the first sample of the frame.</span>
<span class="sd">     seconds_ref</span>
<span class="sd">         start of the scan [s].</span>
<span class="sd">     seconds_duration</span>
<span class="sd">         duration of the scan [s].</span>
<span class="sd">     </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     process_frame : int</span>
<span class="sd">         1 if frame inside scan.</span>
<span class="sd">     after_end_time : int</span>
<span class="sd">         1 if frame after end of defined window.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">process_frame</span><span class="o">=</span><span class="mi">1</span>
    <span class="n">after_end_time</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">if</span> <span class="n">accu_block</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">process_frame</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">elif</span> <span class="n">actual_frame_time</span><span class="o">&lt;</span><span class="n">seconds_ref</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rel_pos_frame</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span> <span class="c1"># if zero then split frame</span>
            <span class="n">process_frame</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">elif</span> <span class="n">actual_frame_time</span><span class="o">&gt;</span><span class="p">(</span><span class="n">seconds_ref</span><span class="o">+</span><span class="n">seconds_duration</span><span class="p">):</span>
        <span class="n">process_frame</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">after_end_time</span><span class="o">=</span><span class="mi">1</span>


    <span class="k">return</span><span class="p">([</span><span class="n">process_frame</span><span class="p">,</span><span class="n">after_end_time</span><span class="p">])</span></div>



<div class="viewcode-block" id="get_seconds_fr_front"><a class="viewcode-back" href="../msvf.html#msvf.get_seconds_fr_front">[docs]</a><span class="k">def</span> <span class="nf">get_seconds_fr_front</span><span class="p">(</span><span class="n">front_time</span><span class="p">,</span><span class="n">vector_seconds_ref</span><span class="p">,</span><span class="n">seconds_frame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find frontier seconds only if not available.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     front_time</span>
<span class="sd">         frontier seconds (i.e. timestamp for start time polynomials).</span>
<span class="sd">     vector_seconds_ref</span>
<span class="sd">         list of floats with seconds for delay information (start time polynomials).</span>
<span class="sd">     seconds_frame</span>
<span class="sd">         seconds corresponding to this frame.</span>
<span class="sd">     </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     seconds_fr_nearest</span>
<span class="sd">         frontier seconds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">front_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span><span class="ow">or</span><span class="p">(</span><span class="n">front_time</span><span class="o">==-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">seconds_fr_nearest</span><span class="o">=</span><span class="n">find_nearest_seconds</span><span class="p">(</span><span class="n">vector_seconds_ref</span><span class="p">,</span><span class="n">seconds_frame</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">seconds_fr_nearest</span><span class="o">=</span><span class="n">front_time</span>
    <span class="k">return</span><span class="p">(</span><span class="n">seconds_fr_nearest</span><span class="p">)</span></div>
    
    

<div class="viewcode-block" id="compute_shift_delay_samples"><a class="viewcode-back" href="../msvf.html#msvf.compute_shift_delay_samples">[docs]</a><span class="k">def</span> <span class="nf">compute_shift_delay_samples</span><span class="p">(</span><span class="n">params_delays</span><span class="p">,</span><span class="n">vector_seconds_ref</span><span class="p">,</span><span class="n">freq_sample</span><span class="p">,</span><span class="n">seconds_frame</span><span class="p">,</span><span class="n">pair_st_so</span><span class="p">,</span><span class="n">data_type</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>\
                                <span class="n">front_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">cache_rates</span><span class="o">=</span><span class="p">[],</span><span class="n">cache_delays</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute number of samples to shift signal (always positive since reference station is closest to source).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     params_delays</span>
<span class="sd">         delay model ini file.</span>
<span class="sd">     vector_seconds_ref</span>
<span class="sd">         list of floats with seconds for delay information (start time polynomials).</span>
<span class="sd">     freq_sample</span>
<span class="sd">         sampling frequency [Hz].</span>
<span class="sd">     seconds_frame</span>
<span class="sd">         seconds corresponding to the frame to be processed.</span>
<span class="sd">     station_id</span>
<span class="sd">         corresponds to id number in stations ini file.</span>
<span class="sd">     source_id</span>
<span class="sd">         [default 0], see limitations.</span>
<span class="sd">     pair_st_so</span>
<span class="sd">     data_type</span>
<span class="sd">         0 for real, 1 for complex.</span>
<span class="sd">     front_time</span>
<span class="sd">         frontier time, that is, time corresponding to the start of the integration period (takes priority over the seconds of the frame)</span>
<span class="sd">     cache_rates</span>
<span class="sd">         temporary information on delays to avoid reprocessing of the input files (see lib_ini_files.get_rates_delays()).</span>
<span class="sd">     cache_delays</span>
<span class="sd">         list with [seconds_fr_nearest,pair_st_so,delay] from previous computation.</span>
<span class="sd">         </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     shift_int</span>
<span class="sd">         number of sample components to offset (integer delay).</span>
<span class="sd">     delay</span>
<span class="sd">         total delay (=freq_sample*(shift_int+fractional_sample_delay)).</span>
<span class="sd">     fractional_sample_delay</span>
<span class="sd">     error_out</span>
<span class="sd">         0 if sucess, -1 if error (e.g. accumulation period not found in ini file)</span>
<span class="sd">     cache_rates</span>
<span class="sd">         updated cache_rates (input).</span>
<span class="sd">     </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    |</span>
<span class="sd">    | **Limitations:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Currently assuming single source (source_id always zero</span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **TO DO:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Simplify code, no need for params_delays nor find_nearest().</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    

    <span class="c1">#print(&quot;ft: &quot;+str(front_time))</span>
    <span class="n">seconds_fr_nearest</span><span class="o">=</span><span class="n">get_seconds_fr_front</span><span class="p">(</span><span class="n">front_time</span><span class="p">,</span><span class="n">vector_seconds_ref</span><span class="p">,</span><span class="n">seconds_frame</span><span class="p">)</span>
    <span class="c1">#seconds_fr_nearest=front_time</span>
    <span class="k">if</span> <span class="n">front_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">seconds_fr_nearest</span><span class="o">=</span><span class="n">find_nearest_seconds</span><span class="p">(</span><span class="n">vector_seconds_ref</span><span class="p">,</span><span class="n">seconds_frame</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">seconds_fr_nearest</span><span class="o">&gt;=-</span><span class="mi">1</span><span class="p">:</span>
        <span class="c1">#rel_epoch=DELAY_MODEL_REL_MARKER+str(seconds_fr_nearest)</span>
        <span class="c1">#found_delay=1</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1">#delay = float(get_param_serial(params_delays,pair_st_so,rel_epoch))</span>
            <span class="p">[</span><span class="n">delay</span><span class="p">,</span><span class="n">cache_delays</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_delay_cache</span><span class="p">(</span><span class="n">seconds_fr_nearest</span><span class="p">,</span><span class="n">pair_st_so</span><span class="p">,</span><span class="n">params_delays</span><span class="p">,</span><span class="n">cache_delays</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1">#found_delay=0</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zM</span><span class="se">\t</span><span class="s2">Warning: could not get delay for pair &quot;</span><span class="o">+</span><span class="n">pair_st_so</span><span class="o">+</span><span class="s2">&quot;, &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">seconds_fr_nearest</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;, skipping frame&quot;</span><span class="p">)</span>
        
            <span class="n">seconds_fr_nearest</span><span class="o">=-</span><span class="mi">2</span>
    
    <span class="k">if</span> <span class="n">seconds_fr_nearest</span><span class="o">&gt;=-</span><span class="mi">1</span><span class="p">:</span>    
        <span class="p">[</span><span class="n">shift_int</span><span class="p">,</span><span class="n">fractional_sample_delay</span><span class="p">]</span><span class="o">=</span><span class="n">get_delay_shift_frac</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span><span class="n">freq_sample</span><span class="p">,</span><span class="n">data_type</span><span class="p">)</span>
        
        <span class="n">error_out</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shift_int</span><span class="o">=-</span><span class="mi">1</span>
        <span class="n">delay</span><span class="o">=-</span><span class="mi">1</span>
        <span class="n">fractional_sample_delay</span><span class="o">=-</span><span class="mi">1</span>
        <span class="n">error_out</span><span class="o">=</span><span class="mi">1</span>
    
    
    
    <span class="k">return</span><span class="p">([</span><span class="n">shift_int</span><span class="p">,</span><span class="n">delay</span><span class="p">,</span><span class="n">fractional_sample_delay</span><span class="p">,</span><span class="n">error_out</span><span class="p">,</span><span class="n">cache_delays</span><span class="p">])</span></div>



<div class="viewcode-block" id="get_absolute_delay"><a class="viewcode-back" href="../msvf.html#msvf.get_absolute_delay">[docs]</a><span class="k">def</span> <span class="nf">get_absolute_delay</span><span class="p">(</span><span class="n">params_delays</span><span class="p">,</span><span class="n">vector_seconds_ref</span><span class="p">,</span><span class="n">seconds_frame</span><span class="p">,</span><span class="n">pair_st_so</span><span class="p">,</span><span class="n">front_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">cache_rates</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get all the delay information structures associated to the processed station, source and integration period.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     params_delays</span>
<span class="sd">         delay model ini file.</span>
<span class="sd">     vector_seconds_ref : list of float</span>
<span class="sd">         seconds for delay information (start time polynomials).</span>
<span class="sd">     seconds_frame</span>
<span class="sd">         seconds corresponding to the frame to be processed.</span>
<span class="sd">     station_id</span>
<span class="sd">         corresponds to id number in stations ini file.</span>
<span class="sd">     source_id</span>
<span class="sd">         [default 0], see limitations.</span>
<span class="sd">     front_time</span>
<span class="sd">         frontier time, that is, time corresponding to the start of the integration period (takes priority over the seconds of the frame)</span>
<span class="sd">     cache_rates</span>
<span class="sd">         temporary information on delays to avoid reprocessing of the input files (see lib_ini_files.get_rates_delays()).</span>
<span class="sd">                         </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     abs_delay</span>
<span class="sd">         initial absolute delay.</span>
<span class="sd">     rate_delay</span>
<span class="sd">         delay polynomials.</span>
<span class="sd">     ref_delay</span>
<span class="sd">         delay for the &quot;reference&quot; station.</span>
<span class="sd">     error_out</span>
<span class="sd">         -1 if station, source and accumulation period not found, 0 if sucess.</span>
<span class="sd">     cache_rates</span>
<span class="sd">         updated cache_rates (input).</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    |</span>
<span class="sd">    | **Configuration:**</span>
<span class="sd">    |</span>
<span class="sd">    |  VERBOSE_INI_DELAYS: from lib_ini_delays.py.</span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **TO DO:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Merge code with compute_shift_delay_samples to avoid repetition.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ref_delay</span><span class="o">=</span><span class="mf">0.0</span>
    <span class="c1"># station_id,source_id(0),params_delay,seconds_frame,freq_sample</span>
    <span class="c1">#pair_st_so = &quot;st&quot;+str(station_id)+&quot;-so&quot;+str(source_id)</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">front_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span><span class="ow">or</span><span class="p">(</span><span class="n">front_time</span><span class="o">==-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">seconds_fr_nearest</span><span class="o">=</span><span class="n">find_nearest_seconds</span><span class="p">(</span><span class="n">vector_seconds_ref</span><span class="p">,</span><span class="n">seconds_frame</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">seconds_fr_nearest</span><span class="o">=</span><span class="n">front_time</span>
       
    <span class="k">if</span> <span class="n">seconds_fr_nearest</span><span class="o">&gt;=-</span><span class="mi">1</span><span class="p">:</span>
        <span class="c1">#abs_epoch=DELAY_MODEL_ABS_MARKER+str(seconds_fr_nearest)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1">#abs_delay = float(get_param_serial(params_delays,pair_st_so,abs_epoch))</span>
            <span class="p">[</span><span class="n">rate_delay</span><span class="p">,</span><span class="n">ref_delay</span><span class="p">,</span><span class="n">abs_delay</span><span class="p">,</span><span class="n">cache_rates</span><span class="p">]</span><span class="o">=</span><span class="n">get_rates_cache</span><span class="p">(</span><span class="n">seconds_fr_nearest</span><span class="p">,</span><span class="n">pair_st_so</span><span class="p">,</span><span class="n">params_delays</span><span class="p">,</span><span class="n">cache_rates</span><span class="p">)</span>
            <span class="n">error_out</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">abs_delay</span><span class="o">=-</span><span class="mi">1</span>
            <span class="n">rate_delay</span><span class="o">=-</span><span class="mi">1</span>
            <span class="n">error_out</span><span class="o">=</span><span class="mi">1</span>   
            
    <span class="k">else</span><span class="p">:</span>
        <span class="n">abs_delay</span><span class="o">=-</span><span class="mi">1</span>
        <span class="n">rate_delay</span><span class="o">=-</span><span class="mi">1</span>
        <span class="n">error_out</span><span class="o">=</span><span class="mi">1</span>
    
    <span class="k">return</span><span class="p">([</span><span class="n">abs_delay</span><span class="p">,</span><span class="n">rate_delay</span><span class="p">,</span><span class="n">ref_delay</span><span class="p">,</span><span class="n">error_out</span><span class="p">,</span><span class="n">cache_rates</span><span class="p">])</span></div>


<div class="viewcode-block" id="adjust_frame_num_and_seconds"><a class="viewcode-back" href="../msvf.html#msvf.adjust_frame_num_and_seconds">[docs]</a><span class="k">def</span> <span class="nf">adjust_frame_num_and_seconds</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span><span class="n">samples_per_channel_in_frame_full</span><span class="p">,</span><span class="n">samples_per_channel_in_frame_single</span><span class="p">,</span>\
                                 <span class="n">second_frame</span><span class="p">,</span><span class="n">frame_num</span><span class="p">,</span><span class="n">shift_int</span><span class="p">,</span><span class="n">acc_time_str</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get adjusted number of frame and shift inside frame considering delays. This is to determine which accumulation</span>
<span class="sd">       period the data corresponding to this frame should go to.</span>
<span class="sd">       </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     fs : float</span>
<span class="sd">         sampling frequency [Hz].</span>
<span class="sd">     samples_per_channel_in_frame_full : int</span>
<span class="sd">         number of samples per channel per frame (full samples, i.e. R or R+jI)</span>
<span class="sd">     samples_per_channel_in_frame_single : int</span>
<span class="sd">         number of sample components (i.e. R, I).</span>
<span class="sd">     second_frame : float</span>
<span class="sd">         seconds corresponding to the first sample of the frame.</span>
<span class="sd">     frame_num : int</span>
<span class="sd">         frame number.</span>
<span class="sd">     shift_int : int</span>
<span class="sd">         shift in number of sample components.</span>
<span class="sd">     acc_time_str : str(float)</span>
<span class="sd">         accumulation period duration [s].</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     frame_num_adjusted</span>
<span class="sd">         frame number considering shift (forced to be positive).</span>
<span class="sd">     frame_num_adjusted_neg</span>
<span class="sd">         frame number considering shift (may be negative)</span>
<span class="sd">     adjusted_shift_inside_frame</span>
<span class="sd">         first sample component inside the frame considering the shift.</span>
<span class="sd">     </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    |</span>
<span class="sd">    | **TO DO:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Remove acc_time_str.</span>
<span class="sd">    |  Check for potential issues in second change... acc_time_str and second_frame are not used!</span>
<span class="sd">    |  (!) Old implementation, may not take into account non-integer multiples of second for acc. period, check (!)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">adjusted_shift_inside_frame</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="n">frames_per_second</span><span class="o">=</span><span class="nb">int</span><span class="p">((</span><span class="n">fs</span><span class="o">/</span><span class="n">samples_per_channel_in_frame_full</span><span class="p">)</span><span class="o">//</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">frame_num_offset</span><span class="o">=</span><span class="n">shift_int</span><span class="o">//</span><span class="n">samples_per_channel_in_frame_single</span>
    <span class="n">frame_num_adjusted</span><span class="o">=</span><span class="n">frame_num</span><span class="o">-</span><span class="n">frame_num_offset</span>
    <span class="n">frame_num_adjusted_neg</span><span class="o">=</span><span class="n">frame_num_adjusted</span>
    
    
    <span class="k">if</span> <span class="n">frame_num_adjusted</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Then they correspond to previous second</span>
        <span class="n">frame_num_adjusted</span><span class="o">=</span><span class="n">frame_num_adjusted</span><span class="o">%</span><span class="n">frames_per_second</span>
    
    <span class="n">adjusted_shift_inside_frame</span><span class="o">=</span><span class="n">shift_int</span><span class="o">%</span><span class="n">samples_per_channel_in_frame_single</span>
    
    <span class="k">return</span><span class="p">([</span><span class="n">frame_num_adjusted</span><span class="p">,</span><span class="n">frame_num_adjusted_neg</span><span class="p">,</span><span class="n">adjusted_shift_inside_frame</span><span class="p">])</span></div>



<div class="viewcode-block" id="get_pointers_samples"><a class="viewcode-back" href="../msvf.html#msvf.get_pointers_samples">[docs]</a><span class="k">def</span> <span class="nf">get_pointers_samples</span><span class="p">(</span><span class="n">tot_samples_one_frame</span><span class="p">,</span><span class="n">adjusted_shift_inside_frame</span><span class="p">,</span><span class="n">accu_block</span><span class="p">,</span>\
                           <span class="n">rel_pos_frame</span><span class="p">,</span><span class="n">tot_samples_sup_frame</span><span class="p">,</span><span class="n">ref_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute metadata relative to sample organization (sample ids, offsets, chunk sizes...).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     tot_samples_one_frame</span>
<span class="sd">         number of samples per channel per frame.</span>
<span class="sd">     adjusted_shift_inside_frame</span>
<span class="sd">         shift (number of samples) for the first sample inside the frame.</span>
<span class="sd">     accu_block</span>
<span class="sd">         accumulation block corresponding to these samples (last sample).</span>
<span class="sd">     rel_pos_frame</span>
<span class="sd">         number of frame relative to the accumulation period.</span>
<span class="sd">     tot_samples_sup_frame</span>
<span class="sd">         number of samples per frame [see notes below].</span>
<span class="sd">     ref_offset</span>
<span class="sd">         integer shift (number of samples) for the first sample of the stream</span>
<span class="sd">     </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     tot_samples_v</span>
<span class="sd">         number of samples in this chunk.</span>
<span class="sd">     seconds_v</span>
<span class="sd">         seconds corresponding to the start of the accumulation period (reference is zero).</span>
<span class="sd">     offset_first_sample_iterator_v</span>
<span class="sd">         offset used to fetch samples from the array with the samples.</span>
<span class="sd">     offset_first_sample_signal_v</span>
<span class="sd">         offset used to compute the position of this chunk in the complete stream.</span>
<span class="sd">     chunk_size_v</span>
<span class="sd">         same as tot_samples_v [remove].</span>
<span class="sd">     acc_v</span>
<span class="sd">         same as seconds_v [remove].</span>
<span class="sd">     </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    |</span>
<span class="sd">    | **TO DO:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Superframe functionality needs debugging.</span>
<span class="sd">    |  Check ref_offset.</span>
<span class="sd">    |  Remove chunk_size_v and acc_v.</span>
<span class="sd">    &quot;&quot;&quot;</span>
                 
    <span class="k">if</span> <span class="n">rel_pos_frame</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="c1"># If first frame of the accumulation period, simply take the part of the data corresponding to this acc period</span>
        <span class="c1"># TO DO: The first part is dismissed, consider adding to previous acc period (?)</span>
        <span class="n">tot_samples_v</span> <span class="o">=</span> <span class="p">[</span><span class="n">tot_samples_sup_frame</span><span class="o">-</span><span class="n">adjusted_shift_inside_frame</span><span class="p">]</span>
        <span class="n">seconds_v</span> <span class="o">=</span> <span class="p">[</span><span class="n">accu_block</span><span class="p">]</span>
        <span class="c1"># Disregard first part...</span>
        <span class="n">offset_first_sample_iterator_v</span><span class="o">=</span><span class="p">[</span><span class="n">adjusted_shift_inside_frame</span><span class="p">]</span>
        <span class="n">offset_first_sample_signal_v</span><span class="o">=</span><span class="p">[</span><span class="n">ref_offset</span><span class="p">]</span>
        <span class="n">chunk_size_v</span> <span class="o">=</span> <span class="n">tot_samples_v</span><span class="p">[:]</span>
        <span class="n">acc_v</span><span class="o">=</span><span class="n">seconds_v</span>
        

    <span class="k">else</span><span class="p">:</span>
        <span class="n">tot_samples_v</span> <span class="o">=</span> <span class="p">[</span><span class="n">tot_samples_sup_frame</span><span class="p">]</span>
        <span class="n">seconds_v</span> <span class="o">=</span> <span class="p">[</span><span class="n">accu_block</span><span class="p">]</span>
        <span class="n">offset_first_sample_iterator_v</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">offset_first_sample_signal_v</span><span class="o">=</span><span class="p">[</span><span class="n">ref_offset</span><span class="o">+</span><span class="n">rel_pos_frame</span><span class="o">*</span><span class="n">tot_samples_one_frame</span><span class="o">-</span><span class="n">adjusted_shift_inside_frame</span><span class="p">]</span>
        <span class="n">chunk_size_v</span><span class="o">=</span><span class="p">[</span><span class="n">tot_samples_sup_frame</span><span class="p">]</span>
        <span class="n">acc_v</span><span class="o">=</span><span class="n">seconds_v</span>
    
    <span class="k">return</span><span class="p">([</span><span class="n">tot_samples_v</span><span class="p">,</span><span class="n">seconds_v</span><span class="p">,</span><span class="n">offset_first_sample_iterator_v</span><span class="p">,</span><span class="n">offset_first_sample_signal_v</span><span class="p">,</span>\
                        <span class="n">chunk_size_v</span><span class="p">,</span><span class="n">acc_v</span><span class="p">])</span></div>



<span class="c1">###########################################</span>
<span class="c1">#           Output data packing</span>
<span class="c1">###########################################</span>


<div class="viewcode-block" id="pack_samples"><a class="viewcode-back" href="../msvf.html#msvf.pack_samples">[docs]</a><span class="k">def</span> <span class="nf">pack_samples</span><span class="p">(</span><span class="n">signal_chunk_fft</span><span class="p">,</span><span class="n">bits_per_sample</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pack the sample components into bytes to avoid data storage overhead.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     signal_chunk_fft : 1D numpy array</span>
<span class="sd">         sample components (integer values).</span>
<span class="sd">     bits_per_sample : int</span>
<span class="sd">         number of bits per sample component.</span>
<span class="sd">     </span>
<span class="sd">    Return</span>
<span class="sd">    -------</span>
<span class="sd">     signal_chunk_fft_out : 1D numpy array</span>
<span class="sd">         bytes containing packed sample components.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">range_offsets</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">bits_per_sample</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">bits_offset</span> <span class="o">=</span> <span class="p">[((</span><span class="n">signal_chunk_fft</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">range_offsets</span><span class="p">]</span>
    <span class="n">bits_extended</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">bits_offset</span><span class="p">)</span>
    
    <span class="n">bits_trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">bits_extended</span><span class="p">,(</span><span class="n">bits_per_sample</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">signal_chunk_fft_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">packbits</span><span class="p">(</span><span class="n">bits_trans</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    
    <span class="k">return</span><span class="p">(</span><span class="n">signal_chunk_fft_out</span><span class="p">)</span></div>


<div class="viewcode-block" id="encode_samples"><a class="viewcode-back" href="../msvf.html#msvf.encode_samples">[docs]</a><span class="k">def</span> <span class="nf">encode_samples</span><span class="p">(</span><span class="n">signal_chunk_fft_out</span><span class="p">,</span><span class="n">encode_b64</span><span class="p">,</span><span class="n">apply_compression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Encode packed samples into base64.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     signal_chunk_fft_out : 1D numpy array</span>
<span class="sd">         bytes containing packed sample components.</span>
<span class="sd">     encode_b64 : int</span>
<span class="sd">         use base64 encoding, 1 by default.</span>
<span class="sd">     apply_compression : int</span>
<span class="sd">         0 by default.</span>
<span class="sd">     </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     signal_chunk_fft_out : str</span>
<span class="sd">         signal encoded into base64.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">encode_b64</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span><span class="ow">and</span><span class="p">(</span><span class="n">apply_compression</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">signal_chunk_fft_out</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64encode</span><span class="p">((</span><span class="n">signal_chunk_fft_out</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">apply_compression</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">signal_chunk_fft_out</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="n">signal_chunk_fft_out</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">signal_chunk_fft_out</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">signal_chunk_fft_out</span><span class="p">)</span> 
    <span class="k">return</span><span class="p">(</span><span class="n">signal_chunk_fft_out</span><span class="p">)</span></div>


<div class="viewcode-block" id="pack_and_encode_samples"><a class="viewcode-back" href="../msvf.html#msvf.pack_and_encode_samples">[docs]</a><span class="k">def</span> <span class="nf">pack_and_encode_samples</span><span class="p">(</span><span class="n">signal_chunk_fft</span><span class="p">,</span><span class="n">use_bitarrays</span><span class="p">,</span><span class="n">encode_b64</span><span class="p">,</span><span class="n">apply_compression</span><span class="p">,</span><span class="n">bits_per_sample</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Encode signal chunk for output of mapper.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     signal_chunk_fft : 1D numpy array of int</span>
<span class="sd">         sample components (integer values).</span>
<span class="sd">     use_bitarrays : int</span>
<span class="sd">         0 by default.</span>
<span class="sd">     encode_b64 : int</span>
<span class="sd">         use base64 encoding, 1 by default.</span>
<span class="sd">     apply_compression : int</span>
<span class="sd">         0 by default.</span>
<span class="sd">     bits_per_sample : int</span>
<span class="sd">         number of bits per sample component.</span>
<span class="sd">  </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     signal_chunk_fft_out : str</span>
<span class="sd">         signal encoded into base64.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    |</span>
<span class="sd">    | **TO DO:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Place together with decode_samples_b64() for better organization.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    

    <span class="k">if</span> <span class="p">(</span><span class="n">use_bitarrays</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">encode_b64</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">signal_chunk_fft_out</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="n">signal_chunk_fft</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">signal_chunk_fft_out</span> <span class="o">=</span> <span class="n">pack_samples</span><span class="p">(</span><span class="n">signal_chunk_fft</span><span class="p">,</span><span class="n">bits_per_sample</span><span class="p">)</span>
            
    <span class="k">else</span><span class="p">:</span>
        <span class="n">signal_chunk_fft_out</span> <span class="o">=</span> <span class="n">signal_chunk_fft</span>
        
    <span class="n">signal_chunk_fft_out</span> <span class="o">=</span> <span class="n">encode_samples</span><span class="p">(</span><span class="n">signal_chunk_fft_out</span><span class="p">,</span><span class="n">encode_b64</span><span class="p">,</span><span class="n">apply_compression</span><span class="p">)</span>
        
    <span class="k">return</span><span class="p">(</span><span class="n">signal_chunk_fft_out</span><span class="p">)</span></div>




<span class="c1">###########################################</span>
<span class="c1">#           Compression</span>
<span class="c1">###########################################</span>


<div class="viewcode-block" id="get_codebook_info"><a class="viewcode-back" href="../msvf.html#msvf.get_codebook_info">[docs]</a><span class="k">def</span> <span class="nf">get_codebook_info</span><span class="p">(</span><span class="n">codecs_serial</span><span class="p">,</span><span class="n">params_media</span><span class="p">,</span><span class="n">current_file_name</span><span class="p">,</span><span class="n">station_name</span><span class="p">,</span><span class="n">chunk_size</span><span class="p">,</span><span class="n">apply_compression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get information for compression library (e.g. vector quantization) if used.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     codecs_serial : str</span>
<span class="sd">         serialized codecs for compression.</span>
<span class="sd">     params_media : str</span>
<span class="sd">         with serialized media.ini.</span>
<span class="sd">     current_file_name : str</span>
<span class="sd">         name of the file currently being processed.</span>
<span class="sd">     station_name : str</span>
<span class="sd">         name of the station.</span>
<span class="sd">     chunk_size : int</span>
<span class="sd">         number of samples per chunk.</span>
<span class="sd">     apply_compression : bool</span>
<span class="sd">         whether to apply compression or not</span>
<span class="sd">     </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     encoding</span>
<span class="sd">         [HARDCODED TO NO COMPRESSION]</span>
<span class="sd">     codebook</span>
<span class="sd">         codebook extracted from the codecs (vector quantization).</span>
<span class="sd">     codebook_name</span>
<span class="sd">         codebook name from .ini.</span>
<span class="sd">     apply_compression</span>
<span class="sd">         updated version of input based on configuration in .ini.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    |</span>
<span class="sd">    | **TO DO:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Harcoded output.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#encoding = get_param_serial(params_media,current_file_name,C_INI_MEDIA_COMPRESSION)</span>
    <span class="c1"># TO DO: Hardcoded value!! Compression disabled</span>
    <span class="n">encoding</span><span class="o">=</span><span class="n">C_INI_MEDIA_C_NO</span>
    
    <span class="k">if</span> <span class="n">encoding</span><span class="o">==</span><span class="n">C_INI_MEDIA_C_NO</span><span class="p">:</span>
        <span class="n">codebook_name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">codebook</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">codebook</span> <span class="o">=</span> <span class="n">get_codebook_from_serial</span><span class="p">(</span><span class="n">codecs_serial</span><span class="p">,</span><span class="n">station_name</span><span class="p">,</span><span class="s2">&quot;-1&quot;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">chunk_size</span><span class="p">)</span>
        <span class="n">codebook_name</span> <span class="o">=</span> <span class="n">get_param_serial</span><span class="p">(</span><span class="n">params_media</span><span class="p">,</span><span class="n">current_file_name</span><span class="p">,</span><span class="n">C_INI_MEDIA_C_CODECS</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">codebook</span><span class="o">!=</span><span class="p">[]:</span>
        <span class="n">apply_compression</span><span class="o">=</span><span class="kc">True</span>
    
    <span class="k">return</span><span class="p">([</span><span class="n">encoding</span><span class="p">,</span><span class="n">codebook</span><span class="p">,</span><span class="n">codebook_name</span><span class="p">,</span><span class="n">apply_compression</span><span class="p">])</span></div>
                    









<span class="c1">###########################################</span>
<span class="c1">#            Main</span>
<span class="c1">###########################################</span>


<div class="viewcode-block" id="main"><a class="viewcode-back" href="../msvf.html#msvf.main">[docs]</a><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="n">read_rest</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">first_sample_signal</span><span class="o">=</span><span class="mi">0</span>


    <span class="c1"># Read parameters                                  # See lib_mapredcorr.get_mapper_params_str() for interface documentation.</span>
    <span class="n">tot_stations</span> <span class="o">=</span>            <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>                 
    <span class="n">tot_pols</span> <span class="o">=</span>                <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>                     
    <span class="n">chunk_size_in</span> <span class="o">=</span>           <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>               
    <span class="n">accumulation_time_str</span> <span class="o">=</span>       <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">seconds_ref</span> <span class="o">=</span>             <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>                
    <span class="n">seconds_duration</span> <span class="o">=</span>      <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>
    <span class="n">first_frame_num</span> <span class="o">=</span>         <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
    <span class="n">num_frames</span> <span class="o">=</span>              <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span>
    <span class="n">auto_stations</span> <span class="o">=</span>           <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">9</span><span class="p">])</span> 
    <span class="n">auto_pols</span> <span class="o">=</span>               <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span>
    <span class="n">use_ini_info</span> <span class="o">=</span>            <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">11</span><span class="p">])</span>
    <span class="n">ini_stations</span> <span class="o">=</span>                <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span>
    <span class="n">ini_media</span> <span class="o">=</span>                   <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>
    <span class="n">ini_delays</span> <span class="o">=</span>                  <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span>
    <span class="n">codecs_serial</span> <span class="o">=</span>               <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span>
    <span class="n">FFT_HERE</span> <span class="o">=</span>                <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">16</span><span class="p">])</span>
    <span class="n">INTERNAL_LOG</span> <span class="o">=</span>            <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">17</span><span class="p">])</span> 
    <span class="n">FFTS_PER_CHUNK</span> <span class="o">=</span>          <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">18</span><span class="p">])</span> 
    <span class="n">WINDOWING</span> <span class="o">=</span>                   <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span>
    <span class="n">ONE_BASELINE_PER_TASK</span> <span class="o">=</span>   <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">20</span><span class="p">])</span>
    <span class="n">PHASE_CALIBRATION</span> <span class="o">=</span>       <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">21</span><span class="p">])</span>
    <span class="n">MIN_MAPPER_CHUNK</span> <span class="o">=</span>        <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">22</span><span class="p">])</span>
    <span class="n">MAX_MAPPER_CHUNK</span> <span class="o">=</span>        <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">23</span><span class="p">])</span>
    <span class="n">TASK_SCALING_STATIONS</span> <span class="o">=</span>   <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">24</span><span class="p">])</span>
    <span class="n">SINGLE_PRECISION</span> <span class="o">=</span>        <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">25</span><span class="p">])</span> <span class="c1"># Currently not used. TO DO: use for FFT at mapper</span>
    
    
    
    <span class="c1"># Experiment configuration</span>
    <span class="c1"># Initialization files</span>
    <span class="n">stations_serial_str</span><span class="o">=</span><span class="n">serialize_config</span><span class="p">(</span><span class="n">ini_stations</span><span class="p">)</span>
    <span class="n">media_serial_str</span><span class="o">=</span><span class="n">serialize_config</span><span class="p">(</span><span class="n">ini_media</span><span class="p">)</span>
    <span class="n">delays_serial_str</span><span class="o">=</span><span class="n">serialize_config</span><span class="p">(</span><span class="n">ini_delays</span><span class="p">)</span>
    <span class="c1"># Serializations into vectors</span>
    <span class="n">params_stations</span><span class="o">=</span><span class="n">serial_params_to_array</span><span class="p">(</span><span class="n">stations_serial_str</span><span class="p">)</span>
    <span class="n">params_media</span><span class="o">=</span><span class="n">serial_params_to_array</span><span class="p">(</span><span class="n">media_serial_str</span><span class="p">)</span>
    <span class="n">params_delays</span><span class="o">=</span><span class="n">serial_params_to_array</span><span class="p">(</span><span class="n">delays_serial_str</span><span class="p">)</span>


    
    <span class="c1"># Frame number ranges</span>
    <span class="c1"># Check frame range if values specified greater than 0</span>
    <span class="n">last_frame_num</span> <span class="o">=</span> <span class="n">first_frame_num</span><span class="o">+</span><span class="n">num_frames</span>
    <span class="n">check_frame_range</span><span class="o">=</span><span class="kc">True</span>
    <span class="k">if</span> <span class="n">first_frame_num</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">last_frame_num</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">check_frame_range</span><span class="o">=</span><span class="kc">False</span>

    
    
    <span class="c1"># Chunk size</span>
    <span class="c1"># Adjust chunk size (may be negative)</span>
    <span class="n">chunk_size_in</span> <span class="o">=</span> <span class="n">chunk_size_in</span> <span class="o">*</span> <span class="n">FFTS_PER_CHUNK</span>
    <span class="c1"># Limit chunk size to avoid problems with line lengths</span>
    <span class="c1"># Minimum size is enforced</span>
    <span class="k">if</span> <span class="n">MAX_MAPPER_CHUNK</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">MAX_MAPPER_CHUNK</span><span class="o">&lt;</span><span class="n">chunk_size_in</span><span class="p">)</span><span class="ow">or</span><span class="p">(</span><span class="n">chunk_size_in</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">chunk_size_in</span><span class="o">=</span><span class="n">MAX_MAPPER_CHUNK</span>
    <span class="k">if</span> <span class="n">MIN_MAPPER_CHUNK</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">MIN_MAPPER_CHUNK</span><span class="o">&gt;</span><span class="n">chunk_size_in</span><span class="p">):</span>
            <span class="n">chunk_size_in</span><span class="o">=</span><span class="n">MIN_MAPPER_CHUNK</span>
    


    <span class="c1"># Name of file currently being processed</span>
    <span class="n">current_file_name</span> <span class="o">=</span> <span class="n">get_current_filename</span><span class="p">()</span>
    


    <span class="n">print_el</span><span class="o">=</span><span class="mi">0</span>               <span class="c1"># used in debugging</span>
    <span class="n">count_print</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">last_pair_st_so</span><span class="o">=</span><span class="s2">&quot;&quot;</span>       <span class="c1"># used in superframes</span>
    <span class="n">sup_frame_id</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">apply_compression</span><span class="o">=</span><span class="kc">False</span>  <span class="c1"># other parameters</span>
    <span class="n">mod_channel</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">frame_num_adjusted</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">tot_samples_per_channel_and_frame</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">actual_num_samples</span><span class="o">=</span><span class="mi">0</span>
    <span class="c1"># data type initials (real / complex)</span>
    <span class="n">data_type_chars</span> <span class="o">=</span> <span class="n">DATA_TYPE_LIST</span>
    <span class="n">ref_offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">freq_sample_in</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">cache_rates</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">cache_delays</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">pairs</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">tot_pairs</span><span class="o">=</span><span class="mi">0</span>

    
    <span class="c1"># Frontiers for accumulation periods</span>
    <span class="n">tot_accu_blocks</span> <span class="o">=</span> <span class="n">get_tot_acc_blocks</span><span class="p">(</span><span class="n">accumulation_time_str</span><span class="p">,</span><span class="n">seconds_duration</span><span class="p">)</span>
    <span class="n">accumulation_time</span><span class="o">=</span><span class="n">get_acc_float</span><span class="p">(</span><span class="n">accumulation_time_str</span><span class="p">)</span>
    <span class="n">list_acc_frontiers</span> <span class="o">=</span> <span class="n">get_list_acc_frontiers</span><span class="p">(</span><span class="n">accumulation_time</span><span class="p">,</span><span class="n">seconds_duration</span><span class="p">,</span><span class="n">seconds_ref</span><span class="p">)</span>
    
    
    <span class="c1"># TO DO: add checks for initialization (?)</span>
    <span class="n">success_init</span><span class="o">=</span><span class="mi">1</span>
    
    
    
    <span class="k">if</span> <span class="n">DEBUG_ALIGN</span><span class="p">:</span>
        <span class="n">print_debug_m_align_header</span><span class="p">()</span>
        
        
        
    
    <span class="c1"># Hadoop reads from stdin</span>
    <span class="n">reader</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span>
    

    <span class="c1">###################################</span>
    <span class="c1">#   Process experiment .ini info</span>
    <span class="c1">###################################</span>

    <span class="c1"># Read information from ini files (default)</span>
    <span class="k">if</span> <span class="n">use_ini_info</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> 
        
        <span class="n">forced_frame_length</span> <span class="o">=</span>                   <span class="nb">int</span><span class="p">(</span><span class="n">get_param_serial</span><span class="p">(</span>   <span class="n">params_media</span><span class="p">,</span><span class="n">current_file_name</span><span class="p">,</span><span class="n">C_INI_MEDIA_FRAMEBYTES</span><span class="p">))</span>
        <span class="n">forced_format</span> <span class="o">=</span>                             <span class="n">get_param_serial</span><span class="p">(</span>   <span class="n">params_media</span><span class="p">,</span><span class="n">current_file_name</span><span class="p">,</span><span class="n">C_INI_MEDIA_FORMAT</span><span class="p">)</span>
        <span class="n">forced_version</span> <span class="o">=</span>                            <span class="n">get_param_serial</span><span class="p">(</span>   <span class="n">params_media</span><span class="p">,</span><span class="n">current_file_name</span><span class="p">,</span><span class="n">C_INI_MEDIA_VERSION</span><span class="p">)</span>
        <span class="n">tot_pols</span> <span class="o">=</span>                                  <span class="n">get_param_total</span><span class="p">(</span>    <span class="n">params_media</span><span class="p">,</span><span class="n">current_file_name</span><span class="p">,</span><span class="n">C_INI_MEDIA_POLARIZATIONS</span><span class="p">)</span>
        
        <span class="n">pols_assoc_vector</span><span class="o">=</span>     <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">get_param_eq_vector</span><span class="p">(</span><span class="n">params_media</span><span class="p">,</span><span class="n">current_file_name</span><span class="p">,</span><span class="n">C_INI_MEDIA_POLARIZATIONS</span><span class="p">)]</span>
        <span class="n">channels_assoc_vector</span><span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">get_param_eq_vector</span><span class="p">(</span><span class="n">params_media</span><span class="p">,</span><span class="n">current_file_name</span><span class="p">,</span><span class="n">C_INI_MEDIA_CHANNELS</span><span class="p">)]</span>
        <span class="n">freqs_assoc_vector</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">get_param_eq_vector</span><span class="p">(</span><span class="n">params_media</span><span class="p">,</span><span class="n">current_file_name</span><span class="p">,</span><span class="n">C_INI_MEDIA_FREQUENCIES</span><span class="p">,</span><span class="n">modein</span><span class="o">=</span><span class="s2">&quot;str&quot;</span><span class="p">)]</span>
        <span class="n">sidebands_assoc_vector</span><span class="o">=</span>                     <span class="n">get_val_vector</span><span class="p">(</span>     <span class="n">params_media</span><span class="p">,</span><span class="n">current_file_name</span><span class="p">,</span><span class="n">C_INI_MEDIA_SIDEBANDS</span><span class="p">)</span>
        <span class="n">freq_sample_in</span> <span class="o">=</span>                   <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">get_param_serial</span><span class="p">(</span>  <span class="n">params_media</span><span class="p">,</span><span class="n">current_file_name</span><span class="p">,</span><span class="n">C_INI_MEDIA_FREQ_SAMPLE</span><span class="p">)))</span>
        <span class="n">station_name</span> <span class="o">=</span>                              <span class="n">get_param_serial</span><span class="p">(</span><span class="n">params_media</span><span class="p">,</span><span class="n">current_file_name</span><span class="p">,</span><span class="n">C_INI_MEDIA_STATION</span><span class="p">)</span>
        
        <span class="n">station_id</span> <span class="o">=</span>                            <span class="nb">int</span><span class="p">(</span><span class="n">get_param_serial</span><span class="p">(</span><span class="n">params_stations</span><span class="p">,</span><span class="n">station_name</span><span class="p">,</span><span class="n">C_INI_ST_ID</span><span class="p">))</span>
        
        <span class="n">num_channels_spec</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">channels_assoc_vector</span><span class="p">))</span>

        <span class="c1">#TODO: generalize for multiple sources...</span>

        
        <span class="c1"># Phase calibration: compute number of bins</span>
        <span class="c1"># TO DO: do specific check instead of exception   </span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fs</span> <span class="o">=</span>                          <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">get_param_serial</span><span class="p">(</span>   <span class="n">params_media</span><span class="p">,</span><span class="n">current_file_name</span><span class="p">,</span><span class="n">C_INI_MEDIA_FREQ_SAMPLE</span><span class="p">))</span><span class="o">//</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">f_pcal</span> <span class="o">=</span>                      <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">get_param_serial</span><span class="p">(</span>   <span class="n">params_media</span><span class="p">,</span><span class="n">current_file_name</span><span class="p">,</span><span class="n">C_INI_MEDIA_F_PCAL</span><span class="p">))</span><span class="o">//</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">o_pcal</span> <span class="o">=</span>                      <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">get_param_serial</span><span class="p">(</span>   <span class="n">params_media</span><span class="p">,</span><span class="n">current_file_name</span><span class="p">,</span><span class="n">C_INI_MEDIA_O_PCAL</span><span class="p">))</span><span class="o">//</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">success_init</span><span class="o">=</span><span class="mi">0</span>
            <span class="c1">#print(&quot;zM&quot;+KEY_SEP+&quot; File &quot;+current_file_name+&quot; not found in configuration.&quot;+current_file_name)</span>
        <span class="k">if</span> <span class="n">success_init</span><span class="p">:</span>
            <span class="p">[</span><span class="n">n_bins_pcal</span><span class="p">,</span><span class="n">pcal_freq</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_pcal_ind</span><span class="p">(</span><span class="n">freqs_assoc_vector</span><span class="p">,</span><span class="n">sidebands_assoc_vector</span><span class="p">,</span><span class="n">fs</span><span class="p">,</span><span class="n">f_pcal</span><span class="p">,</span><span class="n">o_pcal</span><span class="p">)</span>



    <span class="c1"># If error simply read all input (to avoid errors in Hadoop) and exit</span>
    <span class="k">if</span> <span class="n">success_init</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Generate array with correlation pairs.</span>
        <span class="c1">#TO DO: uniformize for different modes</span>
        <span class="k">if</span> <span class="n">ONE_BASELINE_PER_TASK</span><span class="p">:</span>
            <span class="n">pairs</span> <span class="o">=</span> <span class="n">calculate_corr_pairs_one_baseline_per_task</span><span class="p">(</span><span class="n">tot_stations</span><span class="o">=</span><span class="n">tot_stations</span><span class="p">,</span><span class="n">tot_pols</span><span class="o">=</span><span class="n">tot_pols</span><span class="p">,</span>\
                                                        <span class="n">auto_stations</span><span class="o">=</span><span class="n">auto_stations</span><span class="p">,</span><span class="n">auto_pols</span><span class="o">=</span><span class="n">auto_pols</span><span class="p">)</span>
            <span class="n">tot_pairs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
        
        <span class="c1"># If scaling with stations get vectors with allocation.</span>
        <span class="n">tasks_pairs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">if</span> <span class="n">TASK_SCALING_STATIONS</span><span class="p">:</span>
            <span class="n">tasks_pairs</span><span class="o">=</span><span class="n">get_alloc_tasks_linear_scaling</span><span class="p">(</span><span class="n">tot_stations</span><span class="o">*</span><span class="n">tot_pols</span><span class="p">)</span>
            
            
        
        <span class="c1">######################################################</span>
        <span class="c1">#   Loop for reading and processing  VDIF frames</span>
        <span class="c1">######################################################</span>
        
        <span class="n">keep_reading</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">keep_reading</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            
            <span class="c1"># Get header and samples from frame </span>
            <span class="p">[</span><span class="n">header</span><span class="p">,</span><span class="n">allsamples</span><span class="p">,</span><span class="n">check_size_samples</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_frame</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span><span class="n">SHOW_ERRORS</span><span class="p">,</span><span class="n">forced_frame_length</span><span class="p">,</span><span class="n">forced_format</span><span class="p">,</span><span class="n">forced_version</span><span class="p">)</span>
            
            <span class="n">error_frame</span> <span class="o">=</span> <span class="n">C_M_READ_SUCCESS</span>
            
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                
                <span class="c1"># Decode header</span>
                <span class="p">[</span><span class="n">seconds_fr</span><span class="p">,</span><span class="n">invalid</span><span class="p">,</span><span class="n">legacy</span><span class="p">,</span><span class="n">ref_epoch</span><span class="p">,</span><span class="n">frame_num</span><span class="p">,</span><span class="n">vdif_version</span><span class="p">,</span><span class="n">log_2_channels</span><span class="p">,</span>
                    <span class="n">frame_length</span><span class="p">,</span><span class="n">data_type</span><span class="p">,</span><span class="n">bits_per_sample</span><span class="p">,</span><span class="n">thread_id</span><span class="p">,</span><span class="n">station_id_frame</span><span class="p">]</span> <span class="o">=</span> <span class="n">header</span>
                
                <span class="n">actual_num_samples</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">allsamples</span><span class="p">)</span>
                
                <span class="c1">#TO DO: this may not be necessary, used only if compression?</span>
                <span class="c1"># Adjust chunk size if complex data</span>
                <span class="n">chunk_size</span><span class="o">=</span><span class="n">chunk_size_in</span>
                <span class="k">if</span> <span class="n">data_type</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">chunk_size</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">chunk_size_in</span>
                
                <span class="n">process_frame</span> <span class="o">=</span> <span class="mi">1</span>
                
                <span class="c1"># If less samples than expected dismiss frame</span>
                <span class="k">if</span> <span class="n">check_size_samples</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">process_frame</span><span class="o">=</span><span class="mi">0</span>
                    <span class="n">error_frame</span> <span class="o">=</span> <span class="n">C_M_READ_ERR_NO_SAMPLES</span>
                
                <span class="c1"># Override data from the header with serialized info (if applicable)</span>
                <span class="k">if</span> <span class="n">process_frame</span> <span class="ow">and</span> <span class="n">use_ini_info</span><span class="p">:</span>
                    <span class="c1"># TO DO: currently only supporting single source!!</span>
                    <span class="c1"># HARDCODED VALUE: fix this, add support for multiple sources...</span>
                    <span class="n">source_id</span><span class="o">=</span><span class="mi">0</span> 
                    
                    <span class="c1"># TO DO: consider removing</span>
                    <span class="c1"># Not used by default (initially added for compression)</span>
                    <span class="p">[</span><span class="n">encoding</span><span class="p">,</span><span class="n">codebook</span><span class="p">,</span><span class="n">codebook_name</span><span class="p">,</span><span class="n">apply_compression</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_codebook_info</span><span class="p">(</span><span class="n">codecs_serial</span><span class="p">,</span><span class="n">params_media</span><span class="p">,</span><span class="n">current_file_name</span><span class="p">,</span>\
                                                                                   <span class="n">station_name</span><span class="p">,</span><span class="n">chunk_size</span><span class="p">,</span><span class="n">apply_compression</span><span class="p">)</span>
            
                
                <span class="n">pair_st_so</span> <span class="o">=</span> <span class="n">get_pair_st_so</span><span class="p">(</span><span class="n">station_id</span><span class="p">,</span><span class="n">source_id</span><span class="p">)</span>
                <span class="c1"># If same station anad source do not look again for .ini info</span>
                <span class="c1"># TO DO: support for multiple sources...</span>
                <span class="k">if</span> <span class="n">last_pair_st_so</span><span class="o">!=</span><span class="n">pair_st_so</span><span class="p">:</span>
                    <span class="n">vector_params_delay</span> <span class="o">=</span>  <span class="n">get_all_params_serial</span><span class="p">(</span><span class="n">params_delays</span><span class="p">,</span><span class="n">pair_st_so</span><span class="p">)</span>
                    <span class="n">vector_seconds_ref</span> <span class="o">=</span> <span class="n">get_vector_delay_ref</span><span class="p">(</span><span class="n">vector_params_delay</span><span class="p">)</span>
                    <span class="n">vector_params_delay</span><span class="o">=</span><span class="p">[]</span>
                    <span class="n">last_pair_st_so</span><span class="o">=</span><span class="n">pair_st_so</span>
                    <span class="n">sup_frame_id</span><span class="o">=</span><span class="mi">0</span>
                    
                <span class="c1"># Get number of samples per channel</span>
                <span class="n">num_channels</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">log_2_channels</span>
                <span class="p">[</span><span class="n">tot_samples_per_channel_and_frame</span><span class="p">,</span><span class="n">tot_samples_per_channel_and_frame_full</span><span class="p">]</span><span class="o">=</span><span class="n">get_num_samples_per_frame</span><span class="p">(</span><span class="n">allsamples</span><span class="p">,</span><span class="n">num_channels</span><span class="p">,</span><span class="n">data_type</span><span class="p">)</span>
                

                <span class="c1">###########################</span>
                <span class="c1">#   Delay computations</span>
                <span class="c1">###########################</span>

                
                <span class="c1"># Get the timestamp for the first sample in this frame (i.e. adjust integer second with offset of frame number)</span>
                <span class="n">adjusted_frame_time</span><span class="o">=</span><span class="n">adjust_seconds_fr</span><span class="p">(</span><span class="n">tot_samples_per_channel_and_frame_full</span><span class="p">,</span>\
                                                      <span class="n">freq_sample_in</span><span class="p">,</span><span class="n">seconds_fr</span><span class="p">,</span><span class="n">frame_num</span><span class="p">)</span>
                
                
                <span class="c1"># Get absolute delay for this frame, based on its timestamp</span>
                <span class="p">[</span><span class="n">i_f</span><span class="p">,</span><span class="n">front_time</span><span class="p">]</span><span class="o">=</span><span class="n">get_acc_block_for_time</span><span class="p">(</span><span class="n">adjusted_frame_time</span><span class="p">,</span><span class="n">list_acc_frontiers</span><span class="p">)</span>
                <span class="p">[</span><span class="n">abs_delay</span><span class="p">,</span><span class="n">rate_delay</span><span class="p">,</span><span class="n">ref_delay</span><span class="p">,</span><span class="n">error_delay</span><span class="p">,</span><span class="n">cache_rates</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_absolute_delay</span><span class="p">(</span><span class="n">params_delays</span><span class="o">=</span><span class="n">params_delays</span><span class="p">,</span>\
                                                                        <span class="n">vector_seconds_ref</span><span class="o">=</span><span class="n">vector_seconds_ref</span><span class="p">,</span><span class="n">seconds_frame</span><span class="o">=</span><span class="n">adjusted_frame_time</span><span class="p">,</span>\
                                                                        <span class="n">pair_st_so</span><span class="o">=</span><span class="n">pair_st_so</span><span class="p">,</span>\
                                                                        <span class="n">front_time</span><span class="o">=</span><span class="n">front_time</span><span class="p">,</span><span class="n">cache_rates</span><span class="o">=</span><span class="n">cache_rates</span><span class="p">)</span>
                
                <span class="c1"># Shift</span>
                <span class="n">ref_offset</span><span class="o">=</span><span class="n">ref_delay</span><span class="o">*</span><span class="n">fs</span>
                <span class="n">ref_offset</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">modf</span><span class="p">(</span><span class="n">ref_offset</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">data_type</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">ref_offset</span><span class="o">*=</span><span class="mi">2</span>

                
                <span class="k">if</span> <span class="n">error_delay</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">error_frame</span> <span class="o">=</span> <span class="n">C_M_READ_ERR_DELAY_ABS</span>
                    <span class="n">process_frame</span><span class="o">=</span><span class="mi">0</span>

                <span class="k">if</span> <span class="n">process_frame</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">error_delay</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="p">[</span><span class="n">i_f</span><span class="p">,</span><span class="n">front_time</span><span class="p">]</span><span class="o">=</span><span class="n">get_acc_block_for_time</span><span class="p">(</span><span class="n">adjusted_frame_time</span><span class="p">,</span><span class="n">list_acc_frontiers</span><span class="p">)</span>
                    <span class="p">[</span><span class="n">shift_int</span><span class="p">,</span><span class="n">delay</span><span class="p">,</span><span class="n">fractional_sample_delay</span><span class="p">,</span><span class="n">error_delay</span><span class="p">,</span><span class="n">cache_delays</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_shift_delay_samples</span><span class="p">(</span><span class="n">params_delays</span><span class="p">,</span>\
                                        <span class="n">vector_seconds_ref</span><span class="p">,</span><span class="n">freq_sample_in</span><span class="p">,</span><span class="n">adjusted_frame_time</span><span class="p">,</span><span class="n">pair_st_so</span><span class="p">,</span><span class="n">data_type</span><span class="p">,</span>\
                                        <span class="n">front_time</span><span class="p">,</span><span class="n">cache_rates</span><span class="p">,</span><span class="n">cache_delays</span><span class="p">)</span>

                
                    <span class="k">if</span> <span class="n">error_delay</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">process_frame</span><span class="o">=</span><span class="mi">0</span>
                        <span class="n">error_frame</span> <span class="o">=</span> <span class="n">C_M_READ_ERR_DELAY_SHIFT</span>
                
                
            
                <span class="n">print_el</span><span class="o">=</span><span class="mi">0</span>
                <span class="k">if</span> <span class="n">process_frame</span><span class="p">:</span>
                    <span class="n">print_el</span><span class="o">=</span><span class="mi">1</span>
                    <span class="p">[</span><span class="n">frame_num_adjusted</span><span class="p">,</span><span class="n">frame_num_adjusted_neg</span><span class="p">,</span><span class="n">adjusted_shift_inside_frame</span><span class="p">]</span><span class="o">=</span> <span class="n">adjust_frame_num_and_seconds</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span>\
                                                                                    <span class="n">tot_samples_per_channel_and_frame_full</span><span class="p">,</span>\
                                                                                    <span class="n">tot_samples_per_channel_and_frame</span><span class="p">,</span>\
                                                                                    <span class="n">seconds_fr</span><span class="p">,</span>\
                                                                                    <span class="n">frame_num</span><span class="p">,</span>\
                                                                                    <span class="n">shift_int</span><span class="p">,</span><span class="n">accumulation_time</span><span class="p">)</span>

                    <span class="n">actual_frame_time</span><span class="o">=</span><span class="n">adjusted_frame_time</span><span class="o">-</span><span class="n">delay</span>
    
                    <span class="c1"># Frontier with uncorrected times</span>
                    <span class="p">[</span><span class="n">i_front_unc</span><span class="p">,</span><span class="n">acc_block_x_unc</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_acc_block_for_time</span><span class="p">(</span><span class="n">adjusted_frame_time</span><span class="p">,</span> <span class="n">list_acc_frontiers</span><span class="p">)</span>
            
                    <span class="c1"># Frontier with actual times</span>
                    <span class="p">[</span><span class="n">i_front</span><span class="p">,</span><span class="n">acc_block_x</span><span class="p">]</span> <span class="o">=</span>         <span class="n">get_acc_block_for_time</span><span class="p">(</span><span class="n">actual_frame_time</span><span class="p">,</span>   <span class="n">list_acc_frontiers</span><span class="p">)</span>
                    
                    
                    <span class="p">[</span><span class="n">accu_block</span><span class="p">,</span><span class="n">rel_pos_frame</span><span class="p">,</span><span class="n">unused_sec2</span><span class="p">,</span><span class="n">unused_seconds_previous_frame</span><span class="p">,</span><span class="n">unused_frame_num_last</span><span class="p">]</span> <span class="o">=</span>\
                                            <span class="n">get_frame_acc</span><span class="p">(</span><span class="n">seconds_fr</span><span class="p">,</span><span class="n">frame_num_adjusted</span><span class="p">,</span><span class="n">fs</span><span class="p">,</span>\
                                                       <span class="n">tot_samples_per_channel_and_frame_full</span><span class="p">,</span>\
                                                       <span class="n">list_acc_frontiers</span><span class="p">,</span><span class="n">accumulation_time</span><span class="p">)</span>
                    
                    <span class="c1"># If the computed frontiers differ, then the frame is not aligned,</span>
                    <span class="c1">#     i.e. it does not correspond to this acc. period.</span>
                    <span class="n">aligned_frame</span><span class="o">=</span><span class="mi">1</span>
                    <span class="k">if</span> <span class="n">i_front_unc</span><span class="o">!=</span><span class="n">i_front</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i_front_unc</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
                            <span class="n">process_frame</span><span class="o">=</span><span class="mi">0</span>
                        <span class="k">else</span><span class="p">:</span>
                            
                            <span class="c1"># If the relative possition of the frame is not zero, it is a remote station</span>
                            <span class="c1">#if rel_pos_frame!=0:</span>
                            <span class="c1"># make sure it is a remote station (delay is 0 for ref station) # fix for bug on ref station first frame</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">rel_pos_frame</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span><span class="ow">and</span><span class="p">(</span><span class="n">delay</span><span class="o">!=</span><span class="mi">0</span><span class="p">):</span>
                                <span class="n">aligned_frame</span><span class="o">=</span><span class="mi">0</span>
                            
                                <span class="c1"># TO DO: check this</span>
                                <span class="c1"># Force time to be in previous acc period for getting the proper delay model</span>
                                <span class="n">re_adjusted_frame_time</span> <span class="o">=</span> <span class="n">adjusted_frame_time</span><span class="o">-</span><span class="n">accumulation_time</span>
                                
                                <span class="c1"># Recompute based on model for previous acc period</span>
                                <span class="p">[</span><span class="n">i_f</span><span class="p">,</span><span class="n">front_time</span><span class="p">]</span><span class="o">=</span><span class="n">get_acc_block_for_time</span><span class="p">(</span><span class="n">re_adjusted_frame_time</span><span class="p">,</span><span class="n">list_acc_frontiers</span><span class="p">)</span>
                                
                                <span class="p">[</span><span class="n">shift_int</span><span class="p">,</span><span class="n">delay</span><span class="p">,</span><span class="n">fractional_sample_delay</span><span class="p">,</span>\
                                 <span class="n">error_delay</span><span class="p">,</span><span class="n">cache_delays</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_shift_delay_samples</span><span class="p">(</span><span class="n">params_delays</span><span class="p">,</span><span class="n">vector_seconds_ref</span><span class="p">,</span>\
                                                <span class="n">freq_sample_in</span><span class="p">,</span><span class="n">re_adjusted_frame_time</span><span class="p">,</span><span class="n">pair_st_so</span><span class="p">,</span><span class="n">data_type</span><span class="p">,</span>\
                                                <span class="n">front_time</span><span class="p">,</span><span class="n">cache_rates</span><span class="p">,</span><span class="n">cache_delays</span><span class="p">)</span>
                                
                                <span class="p">[</span><span class="n">frame_num_adjusted</span><span class="p">,</span><span class="n">frame_num_adjusted_neg</span><span class="p">,</span>\
                                 <span class="n">adjusted_shift_inside_frame</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjust_frame_num_and_seconds</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span>\
                                                            <span class="n">tot_samples_per_channel_and_frame_full</span><span class="p">,</span>\
                                                            <span class="n">tot_samples_per_channel_and_frame</span><span class="p">,</span>\
                                                            <span class="n">seconds_fr</span><span class="p">,</span><span class="n">frame_num</span><span class="p">,</span><span class="n">shift_int</span><span class="p">,</span><span class="n">accumulation_time</span><span class="p">)</span>
    
                                
                                <span class="n">actual_frame_time</span> <span class="o">=</span> <span class="n">adjusted_frame_time</span><span class="o">-</span><span class="n">delay</span>
                                
                                <span class="p">[</span><span class="n">i_front_unc</span><span class="p">,</span><span class="n">acc_block_x_unc</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_acc_block_for_time</span><span class="p">(</span><span class="n">adjusted_frame_time</span><span class="p">,</span><span class="n">list_acc_frontiers</span><span class="p">)</span>
                                <span class="p">[</span><span class="n">i_front</span><span class="p">,</span><span class="n">acc_block_x</span><span class="p">]</span> <span class="o">=</span>         <span class="n">get_acc_block_for_time</span><span class="p">(</span><span class="n">actual_frame_time</span><span class="p">,</span><span class="n">list_acc_frontiers</span><span class="p">)</span>

                                <span class="p">[</span><span class="n">unused_accu_block_no</span><span class="p">,</span><span class="n">rel_pos_frame</span><span class="p">,</span><span class="n">unused_sec2no</span><span class="p">,</span>\
                                     <span class="n">unused_seconds_previous_frameno</span><span class="p">,</span>\
                                     <span class="n">unused_frame_num_lastno</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_frame_acc</span><span class="p">(</span><span class="n">actual_frame_time</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">fs</span><span class="p">,</span>\
                                                                <span class="n">tot_samples_per_channel_and_frame_full</span><span class="p">,</span>\
                                                                <span class="n">list_acc_frontiers</span><span class="p">,</span><span class="n">accumulation_time</span><span class="p">)</span> 

                    
                    
                    <span class="c1"># Correct acc period for aligned frame with offset (due to references always to first sample of the frame)</span>
                    <span class="c1">#if (rel_pos_frame==0)and(adjusted_shift_inside_frame!=0):</span>
                    <span class="c1"># fix for bug offset lesser than one sample</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">rel_pos_frame</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="ow">and</span><span class="p">((</span><span class="n">adjusted_shift_inside_frame</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span><span class="ow">or</span><span class="p">(</span><span class="n">delay</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)):</span>
                        <span class="n">i_front</span><span class="o">+=</span><span class="mi">1</span>

                    <span class="k">elif</span> <span class="p">(</span><span class="n">rel_pos_frame</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
                        <span class="c1"># Correct also delay lesser than one sample in first frame of acc block</span>
                        <span class="c1"># TO DO: ned more elegant solution to these fixes</span>
                        <span class="p">[</span><span class="n">i_front_second_sample</span><span class="p">,</span><span class="n">acc_block_second_sample</span><span class="p">]</span><span class="o">=</span><span class="n">get_acc_block_for_time</span><span class="p">(</span><span class="n">actual_frame_time</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">fs</span><span class="p">),</span><span class="n">list_acc_frontiers</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">i_front_second_sample</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                            <span class="n">i_front</span><span class="o">=</span><span class="n">i_front_second_sample</span>
                            <span class="n">acc_block_x</span><span class="o">=</span><span class="n">acc_block_second_sample</span>

                    <span class="n">accu_block</span><span class="o">=</span><span class="n">i_front</span>
                    
                    <span class="c1"># Finally get polynomials for this acc period (for -1 will get last, but will not be taken to output)</span>
                    <span class="n">front_acc</span> <span class="o">=</span> <span class="n">list_acc_frontiers</span><span class="p">[</span><span class="n">accu_block</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">front_acc</span><span class="o">==</span><span class="n">list_acc_frontiers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">front_acc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="p">[</span><span class="n">shift_int</span><span class="p">,</span><span class="n">delay</span><span class="p">,</span><span class="n">fractional_sample_delay</span><span class="p">,</span><span class="n">error_delay</span><span class="p">,</span><span class="n">cache_delays</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_shift_delay_samples</span><span class="p">(</span><span class="n">params_delays</span><span class="p">,</span>\
                                                                                    <span class="n">vector_seconds_ref</span><span class="p">,</span><span class="n">freq_sample_in</span><span class="p">,</span>\
                                                                                    <span class="n">front_acc</span><span class="p">,</span><span class="n">pair_st_so</span><span class="p">,</span>\
                                                                                    <span class="n">data_type</span><span class="p">,</span>\
                                                                                    <span class="n">front_acc</span><span class="p">,</span><span class="n">cache_rates</span><span class="p">,</span><span class="n">cache_delays</span><span class="p">)</span>

                    
                    <span class="k">if</span> <span class="n">frame_num_adjusted_neg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="p">[</span><span class="n">unused_accu_block_no</span><span class="p">,</span><span class="n">rel_pos_frame</span><span class="p">,</span><span class="n">unused_sec2no</span><span class="p">,</span>
                             <span class="n">unused_seconds_previous_frameno</span><span class="p">,</span><span class="n">unused_frame_num_lastno</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_frame_acc</span><span class="p">(</span><span class="n">actual_frame_time</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">fs</span><span class="p">,</span>\
                                                                                         <span class="n">tot_samples_per_channel_and_frame_full</span><span class="p">,</span>\
                                                                                         <span class="n">list_acc_frontiers</span><span class="p">,</span><span class="n">accumulation_time</span><span class="p">)</span>                    
                    
                    
                    <span class="k">if</span> <span class="n">DEBUG_ALIGN</span><span class="p">:</span>
                        <span class="n">print_debug_m_align_no_end</span><span class="p">(</span><span class="n">station_name</span><span class="p">,</span><span class="n">station_id</span><span class="p">,</span><span class="n">tot_samples_per_channel_and_frame</span><span class="p">,</span><span class="n">data_type</span><span class="p">,</span>\
                                        <span class="n">tot_samples_per_channel_and_frame_full</span><span class="p">,</span><span class="n">seconds_fr</span><span class="p">,</span><span class="n">frame_num</span><span class="p">,</span><span class="n">adjusted_frame_time</span><span class="p">,</span>\
                                        <span class="n">delay</span><span class="p">,</span><span class="n">actual_frame_time</span><span class="p">,</span><span class="n">rel_pos_frame</span><span class="p">,</span><span class="n">i_front</span><span class="p">,</span><span class="n">accu_block</span><span class="p">,</span><span class="n">frame_num_adjusted_neg</span><span class="p">,</span>\
                                        <span class="n">frame_num_adjusted</span><span class="p">,</span><span class="n">shift_int</span><span class="p">,</span><span class="n">adjusted_shift_inside_frame</span><span class="p">,</span><span class="n">fractional_sample_delay</span><span class="p">,</span>\
                                        <span class="n">process_frame</span><span class="p">,</span><span class="n">aligned_frame</span><span class="p">,</span><span class="n">count_print</span><span class="p">)</span>
                        
                    <span class="n">count_print</span><span class="o">=</span><span class="mi">0</span>  <span class="c1"># For debugging, number of output lines per frame, updated below</span>
                    
                    

                <span class="k">if</span> <span class="n">process_frame</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">DEBUG_ALIGN</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">print_el</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                            
                            
                <span class="k">if</span> <span class="n">process_frame</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    
                    <span class="c1">###########################</span>
                    <span class="c1">#   Corner-turning</span>
                    <span class="c1">###########################</span>
                    
                    <span class="c1"># Reshape array with samples (corner turning)</span>
                    <span class="n">samples</span> <span class="o">=</span> <span class="n">lib_vdif</span><span class="o">.</span><span class="n">reshape_samples</span><span class="p">(</span><span class="n">allsamples</span><span class="p">,</span><span class="n">data_type</span><span class="p">,</span><span class="n">tot_samples_per_channel_and_frame</span><span class="p">,</span><span class="n">num_channels</span><span class="p">)</span>
                    

                        
                    <span class="c1"># read media.ini file to figure out correspondences between channels and band/polarizations</span>
                    <span class="c1"># Change these with the new values after processing media.ini</span>
                    <span class="n">mod_polarization_id</span> <span class="o">=</span> <span class="n">thread_id</span>
                    <span class="n">mod_channels</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">num_channels</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">use_ini_info</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">mod_polarization_ids</span> <span class="o">=</span> <span class="n">pols_assoc_vector</span>
                        <span class="n">mod_channels</span> <span class="o">=</span> <span class="n">channels_assoc_vector</span>


                    <span class="c1">###########################</span>
                    <span class="c1">#   Super-frames</span>
                    <span class="c1">###########################</span>
                    
                    <span class="c1"># TO DO: add support for superframes (i.e. multiple frames per output) here</span>
                    <span class="c1"># Currently disabled</span>
                    
                    <span class="n">do_sup_frame</span><span class="o">=</span><span class="mi">0</span>
                    <span class="k">if</span> <span class="n">num_channels</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># Multichannel and thus few samples per frame for each channel</span>
                        <span class="c1"># Will do superframe grouping NUM_FRAMES_PER_LINE frames</span>
                        <span class="k">if</span> <span class="n">NUM_FRAMES_PER_LINE</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                            <span class="c1">#accu_block</span>
                            <span class="c1"># Get acc block for last frame in super frame</span>
                            <span class="n">offset_num_frames</span><span class="o">=</span><span class="n">NUM_FRAMES_PER_LINE</span><span class="o">*</span><span class="n">tot_samples_per_channel_and_frame_full</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
                            <span class="p">[</span><span class="n">accu_block_last_sup</span><span class="p">,</span><span class="n">acc_unused</span><span class="p">]</span><span class="o">=</span><span class="n">get_acc_block_for_time</span><span class="p">(</span><span class="n">actual_frame_time</span><span class="o">+</span><span class="n">offset_num_frames</span><span class="p">,</span><span class="n">list_acc_frontiers</span><span class="p">)</span>
                            <span class="n">whole_sup_frame</span><span class="o">=</span><span class="mi">0</span>
                            <span class="k">if</span> <span class="n">accu_block</span><span class="o">==</span><span class="n">accu_block_last_sup</span><span class="p">:</span>
                                <span class="n">whole_sup_frame</span><span class="o">=</span><span class="mi">1</span>
                                <span class="k">if</span> <span class="n">whole_sup_frame</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">sup_frame_id</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                                        <span class="n">do_sup_frame</span><span class="o">=</span><span class="mi">1</span>
                                        <span class="c1"># initialize</span>
                                        
                                        <span class="n">first_in_sup_info</span> <span class="o">=</span> <span class="p">[</span><span class="n">adjusted_shift_inside_frame</span><span class="p">,</span><span class="n">accu_block</span><span class="p">,</span><span class="n">rel_pos_frame</span><span class="p">,</span>\
                                                             <span class="n">actual_frame_time</span><span class="p">,</span><span class="n">seconds_ref</span><span class="p">,</span><span class="n">seconds_duration</span><span class="p">]</span>
                                        <span class="n">u_tot_samples_per_channel_and_frame</span> <span class="o">=</span> <span class="n">tot_samples_per_channel_and_frame</span>
                                        <span class="n">u_samples</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
                                        
                                        
                                    <span class="k">elif</span> <span class="n">sup_frame_id</span><span class="o">==</span><span class="p">(</span><span class="n">NUM_FRAMES_PER_LINE</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                                        <span class="c1"># last frame, write</span>
                                        <span class="n">do_sup_frame</span><span class="o">=</span><span class="mi">1</span>
                                        
                                        <span class="p">[</span><span class="n">adjusted_shift_inside_frame</span><span class="p">,</span><span class="n">accu_block</span><span class="p">,</span><span class="n">rel_pos_frame</span><span class="p">,</span>\
                                         <span class="n">actual_frame_time</span><span class="p">,</span><span class="n">seconds_ref</span><span class="p">,</span><span class="n">seconds_duration</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_in_sup_info</span>
                                        <span class="n">u_tot_samples_per_channel_and_frame</span><span class="o">+=</span><span class="n">tot_samples_per_channel_and_frame</span>
                                        
                                        <span class="n">tot_samples_sup_frame</span><span class="o">=</span><span class="n">u_tot_samples_per_channel_and_frame</span>
                                        <span class="n">u_samples</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">u_samples</span><span class="p">,</span><span class="n">samples</span><span class="p">))</span>
                                        <span class="n">samples</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">u_samples</span><span class="p">)</span>
                                        
                                        
                                        
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="c1"># continue storing</span>
                                        <span class="n">u_tot_samples_per_channel_and_frame</span><span class="o">+=</span><span class="n">tot_samples_per_channel_and_frame</span>
                                        
                                        <span class="n">u_samples</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">u_samples</span><span class="p">,</span><span class="n">samples</span><span class="p">))</span>
                                        
                                        <span class="n">do_sup_frame</span><span class="o">=</span><span class="mi">1</span>
                                        

                            <span class="k">if</span> <span class="n">do_sup_frame</span><span class="p">:</span>
                                <span class="n">sup_frame_id</span><span class="o">=</span><span class="p">(</span><span class="n">sup_frame_id</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">NUM_FRAMES_PER_LINE</span>
                    
                    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">do_sup_frame</span><span class="p">):</span>
                        <span class="n">tot_samples_sup_frame</span><span class="o">=</span><span class="n">tot_samples_per_channel_and_frame</span>
                    
                    
                    <span class="c1"># sup_frame_id has been increased, thus check for 0, not last </span>
                    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">do_sup_frame</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">do_sup_frame</span> <span class="ow">and</span> <span class="n">sup_frame_id</span><span class="o">==</span><span class="mi">0</span><span class="p">)):</span>
                        <span class="c1"># Superframe, will not print until last frame in superframe</span>
                        <span class="k">if</span> <span class="n">DEBUG_ALIGN</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">print_el</span><span class="p">:</span>
                                <span class="n">print_sup_frame</span><span class="p">(</span><span class="n">sup_frame_id</span><span class="p">)</span>
                    
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Normal processing</span>
                        <span class="n">tot_samples</span><span class="o">=</span><span class="n">tot_samples_per_channel_and_frame</span>
                        <span class="c1"># TO DO: Delete?</span>
                        <span class="k">if</span> <span class="n">tot_samples</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                            <span class="n">tot_samples</span><span class="o">=</span><span class="mi">0</span>
                        
                        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">do_sup_frame</span><span class="p">):</span>
                            <span class="n">tot_samples_sup_frame</span><span class="o">=</span><span class="n">tot_samples</span>
                        
                        <span class="c1">##################################</span>
                        <span class="c1">#   Offsets for accessing samples</span>
                        <span class="c1">##################################</span>
                        
                        <span class="c1"># Get pointers to the samples</span>
                        <span class="p">[</span><span class="n">tot_samples_v</span><span class="p">,</span><span class="n">seconds_v</span><span class="p">,</span><span class="n">offset_first_sample_iterator_v</span><span class="p">,</span>\
                             <span class="n">offset_first_sample_signal_v</span><span class="p">,</span><span class="n">chunk_size_v</span><span class="p">,</span><span class="n">acc_v</span><span class="p">]</span> <span class="o">=</span> \
                                    <span class="n">get_pointers_samples</span><span class="p">(</span><span class="n">tot_samples</span><span class="p">,</span><span class="n">adjusted_shift_inside_frame</span><span class="p">,</span>\
                                                    <span class="n">accu_block</span><span class="p">,</span><span class="n">rel_pos_frame</span><span class="p">,</span><span class="n">tot_samples_sup_frame</span><span class="p">,</span><span class="n">ref_offset</span><span class="p">)</span>
                                                               
    
                        <span class="k">if</span> <span class="n">DEBUG_ALIGN</span><span class="p">:</span>
                            <span class="n">print_debug_m_align_last</span><span class="p">(</span><span class="n">tot_samples_v</span><span class="p">,</span><span class="n">seconds_v</span><span class="p">,</span><span class="n">offset_first_sample_iterator_v</span><span class="p">,</span><span class="n">offset_first_sample_signal_v</span><span class="p">,</span>\
                                              <span class="n">chunk_size_v</span><span class="p">,</span><span class="n">acc_v</span><span class="p">,</span><span class="n">do_sup_frame</span><span class="p">,</span><span class="n">sup_frame_id</span><span class="p">)</span>
                
                    
                    
                    
                        <span class="c1"># Iterate on groups (or chunks) of samples for this frame, always one group with the data for this</span>
                        <span class="c1">#    initially devised to consider the first group too (corresponding to the previous acc period).</span>
                        <span class="k">for</span> <span class="p">(</span><span class="n">tot_samples</span><span class="p">,</span><span class="n">seconds_fr</span><span class="p">,</span><span class="n">offset_first_sample_iterator</span><span class="p">,</span>\
                              <span class="n">offset_first_sample_signal</span><span class="p">,</span><span class="n">chunk_size</span><span class="p">,</span><span class="n">accu_block</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tot_samples_v</span><span class="p">,</span><span class="n">seconds_v</span><span class="p">,</span>\
                                                                <span class="n">offset_first_sample_iterator_v</span><span class="p">,</span><span class="n">offset_first_sample_signal_v</span><span class="p">,</span><span class="n">chunk_size_v</span><span class="p">,</span><span class="n">acc_v</span><span class="p">):</span>
                        
                            
                            <span class="c1"># Check if samples will be processed (i.e. if inside of requested time window)</span>
                            <span class="p">[</span><span class="n">process_frame</span><span class="p">,</span><span class="n">after_end_time</span><span class="p">]</span> <span class="o">=</span> <span class="n">check_time_frame</span><span class="p">(</span><span class="n">accu_block</span><span class="p">,</span><span class="n">rel_pos_frame</span><span class="p">,</span><span class="n">actual_frame_time</span><span class="p">,</span><span class="n">seconds_ref</span><span class="p">,</span><span class="n">seconds_duration</span><span class="p">)</span>
                            
                            <span class="c1"># Stop reading if already passed end time</span>
                            <span class="c1"># TO DO: make this configurable</span>
                            <span class="k">if</span> <span class="n">after_end_time</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                                <span class="n">keep_reading</span><span class="o">=</span><span class="mi">0</span>
                                <span class="c1"># (!) This must be done to avoid &quot;cat: write error: Broken pipe&quot;</span>
                                <span class="c1"># All the data from stdin must be read</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">read_rest</span><span class="o">=</span><span class="mi">1</span>
                                    <span class="n">rest_reading</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                                <span class="k">except</span> <span class="ne">EOFError</span><span class="p">:</span>
                                    <span class="n">error_reading_rest</span><span class="o">=</span><span class="mi">1</span>
                                    <span class="c1">#print(&quot;zM&quot;+KEY_SEP+&quot;EOF reading rest of file &quot;+current_file_name)</span>
                            
                            
                            <span class="c1"># Otherwise check frame number range</span>
                            <span class="k">elif</span> <span class="n">check_frame_range</span><span class="p">:</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">frame_num</span><span class="o">&lt;</span><span class="n">first_frame_num</span><span class="p">)</span><span class="ow">or</span><span class="p">(</span><span class="n">frame_num</span><span class="o">&gt;=</span><span class="n">last_frame_num</span><span class="p">):</span>
                                    <span class="n">process_frame</span><span class="o">=</span><span class="mi">0</span>
                                    <span class="c1"># Keep reading, but do not process this frame</span>
                            
                            
                            <span class="k">if</span> <span class="n">process_frame</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                            
                                <span class="n">tot_chunks</span><span class="o">=</span><span class="mi">1</span>
                                <span class="n">check_tot_chunks</span><span class="o">=-</span><span class="mi">1</span>
                                
                                <span class="c1">#Generate one new line for each chunk</span>
                                <span class="c1"># Default case: one chunk, to avoid overhead</span>
                                <span class="c1"># TO DO: simplify code, tot_chunks=1</span>
                                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tot_chunks</span><span class="p">):</span>
                                    <span class="c1">#Calculate iterators for limits of the chunk (indices in array &quot;samples&quot;)</span>
                                    <span class="n">iterator_first_sample_base</span><span class="o">=</span><span class="n">i</span><span class="o">*</span><span class="n">chunk_size</span>
                                    
                                    <span class="c1"># Pointers to data (to be used when fetching samples from array)</span>
                                    <span class="n">iterator_first_sample</span><span class="o">=</span><span class="n">iterator_first_sample_base</span><span class="o">+</span><span class="n">offset_first_sample_iterator</span>
                                    <span class="n">iterator_last_sample</span><span class="o">=</span><span class="n">iterator_first_sample</span><span class="o">+</span><span class="n">chunk_size</span>
                            
                                    <span class="c1"># Sample number (to be used later at the reducer)</span>
                                    <span class="n">first_sample_signal</span><span class="o">=</span><span class="n">iterator_first_sample_base</span><span class="o">+</span><span class="n">offset_first_sample_signal</span>
                            
                                    <span class="n">re_signal_chunk_quantized</span><span class="o">=</span><span class="n">samples</span><span class="p">[:,</span><span class="n">iterator_first_sample</span><span class="p">:</span><span class="n">iterator_last_sample</span><span class="p">]</span>
                                
                                    <span class="c1">#Loop here for multiple channels (if single channel, check number of thread for channel id)</span>
                                    <span class="n">mod_channel_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                                    <span class="k">for</span> <span class="n">signal_chunk_quantized</span> <span class="ow">in</span> <span class="n">re_signal_chunk_quantized</span><span class="p">:</span>
                                
                                        <span class="c1">###########################</span>
                                        <span class="c1">#   Samples for one band</span>
                                        <span class="c1">###########################</span>
                                
                                        <span class="c1"># TODO: this assumes that only threads or bands are used! Need to add option.</span>
                                        <span class="c1">#if thread_id&gt;0:</span>
                                        <span class="k">if</span> <span class="n">num_channels</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                                            <span class="n">mod_channel_index</span> <span class="o">=</span> <span class="n">thread_id</span>
                                        <span class="k">else</span><span class="p">:</span>
                                            <span class="n">mod_channel_index</span> <span class="o">+=</span> <span class="mi">1</span>
                                        
                                        <span class="c1"># metadata for this band</span>
                                        <span class="n">mod_polarization_id</span> <span class="o">=</span>  <span class="n">mod_polarization_ids</span><span class="p">[</span><span class="n">mod_channel_index</span><span class="p">]</span>
                                        <span class="n">mod_channel</span> <span class="o">=</span>          <span class="n">mod_channels</span><span class="p">[</span><span class="n">mod_channel_index</span><span class="p">]</span>
                                        <span class="n">n_bins_pcal_val</span> <span class="o">=</span>      <span class="n">n_bins_pcal</span><span class="p">[</span><span class="n">mod_channel_index</span><span class="p">]</span>
                                        <span class="n">freq_channel</span> <span class="o">=</span>         <span class="n">freqs_assoc_vector</span><span class="p">[</span><span class="n">mod_channel_index</span><span class="p">]</span>
                                        <span class="n">sideband</span> <span class="o">=</span>             <span class="n">sidebands_assoc_vector</span><span class="p">[</span><span class="n">mod_channel_index</span><span class="p">]</span>
                                
                                        <span class="c1"># By default fft in reducer</span>
                                        <span class="c1"># Consider removing and doing DFT always in reducer</span>
                                        <span class="k">if</span> <span class="n">FFT_HERE</span><span class="p">:</span>
                                            <span class="c1"># No bypass:</span>
                                            <span class="n">signal_chunk_quantized_int</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">signal_chunk_quantized</span><span class="p">)</span>
                                            <span class="n">signal_chunk</span> <span class="o">=</span> <span class="n">simple_dequantizer</span><span class="p">(</span><span class="n">signal_chunk_quantized_int</span><span class="p">,</span><span class="n">bits_per_sample</span><span class="p">)</span>
                                            <span class="c1"># Complex if applicable</span>
                                            <span class="k">if</span> <span class="n">data_type</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                                                <span class="n">signal_chunk</span><span class="o">=</span><span class="n">group_pairs_complex</span><span class="p">(</span><span class="n">signal_chunk</span><span class="p">)</span>
                                                
                                            <span class="c1"># TO DO: Changes untested</span>
                                            <span class="c1"># TO DO: windowing</span>
                                            <span class="n">signal_chunk_fft</span><span class="o">=</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="n">scipy</span><span class="o">.</span><span class="n">fftpack</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">signal_chunk</span><span class="p">))</span>
                                        <span class="k">else</span><span class="p">:</span>
                                            <span class="c1"># Bypass:</span>
                                            <span class="n">signal_chunk_fft</span><span class="o">=</span><span class="n">signal_chunk_quantized</span>
                                        
                                        <span class="c1">###########################</span>
                                        <span class="c1">#   Encode samples</span>
                                        <span class="c1">###########################</span>
                                        
                                        <span class="c1"># VQ: Compression</span>
                                        <span class="c1"># No need to specify station, already in info (id)</span>
                                        <span class="k">if</span> <span class="n">apply_compression</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                                            <span class="p">[</span><span class="n">encoded</span><span class="p">,</span><span class="n">codeb</span><span class="p">]</span><span class="o">=</span><span class="n">encode_vq</span><span class="p">(</span><span class="n">input_signal</span><span class="o">=</span><span class="n">signal_chunk_fft</span><span class="o">.</span><span class="n">to01</span><span class="p">(),</span><span class="n">chunk_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">num_codes</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">whitten</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">code_book</span><span class="o">=</span><span class="n">codebook</span><span class="p">,</span><span class="n">process_fraction</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                                            
                                            <span class="c1"># Changes untested!</span>
                                            <span class="n">signal_chunk_fft</span><span class="o">=</span><span class="p">[</span><span class="n">chunk_size</span><span class="p">]</span><span class="o">+</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="nb">list</span><span class="p">(</span><span class="n">encoded</span><span class="p">))</span>
                                
                                        <span class="c1">#For each pair where the station belongs, create a line in stdout </span>
                                        <span class="n">num_samples_in_chunk</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">signal_chunk_fft</span><span class="p">)</span>
                                        <span class="n">signal_chunk_fft_out</span> <span class="o">=</span> <span class="n">pack_and_encode_samples</span><span class="p">(</span><span class="n">signal_chunk_fft</span><span class="p">,</span><span class="n">USE_BITARRAYS</span><span class="p">,</span><span class="n">ENCODE_B64</span><span class="p">,</span><span class="n">apply_compression</span><span class="p">,</span><span class="n">bits_per_sample</span><span class="p">)</span>
                                        
                                        
                                        <span class="c1">###########################</span>
                                        <span class="c1">#   Generate output</span>
                                        <span class="c1">###########################</span>
                                        
                                        <span class="c1"># TO DO: unify all modes</span>
                                        <span class="k">if</span> <span class="p">(</span><span class="n">ONE_BASELINE_PER_TASK</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
                                            <span class="k">if</span> <span class="n">TASK_SCALING_STATIONS</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                                                
                                                <span class="c1"># All-baselines-per-task</span>
                                                <span class="n">pair</span><span class="o">=</span><span class="n">get_pair_all_baselines_per_task</span><span class="p">()</span>
                                                
                                                <span class="c1"># Char to identify mode</span>
                                                <span class="n">char_p</span><span class="o">=</span><span class="s2">&quot;x&quot;</span>
                                                <span class="n">pair_str</span> <span class="o">=</span> <span class="n">get_pair_str</span><span class="p">(</span><span class="n">char_p</span><span class="p">,</span><span class="n">pair</span><span class="p">,</span><span class="n">accu_block</span><span class="p">,</span><span class="n">mod_channel</span><span class="p">,</span><span class="n">num_channels_spec</span><span class="p">,</span>\
                                                                        <span class="n">accu_block</span><span class="p">,</span><span class="n">first_sample_signal</span><span class="p">,</span>\
                                                                        <span class="n">station_id</span><span class="p">,</span><span class="n">mod_polarization_id</span><span class="p">,</span>\
                                                                        <span class="n">freq_sample_in</span><span class="p">,</span><span class="n">bits_per_sample</span><span class="p">,</span><span class="n">data_type_chars</span><span class="p">[</span><span class="n">data_type</span><span class="p">],</span>\
                                                                        <span class="n">encoding</span><span class="p">,</span><span class="n">n_bins_pcal_val</span><span class="p">,</span><span class="n">pcal_freq</span><span class="p">,</span>\
                                                                        <span class="n">ONE_BASELINE_PER_TASK</span><span class="p">,</span><span class="n">TASK_SCALING_STATIONS</span><span class="p">,</span>\
                                                                        <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>\
                                                                        <span class="n">num_samples_in_chunk</span><span class="p">,</span><span class="n">abs_delay</span><span class="p">,</span><span class="n">rate_delay</span><span class="p">,</span><span class="n">freq_channel</span><span class="p">,</span>\
                                                                        <span class="n">fractional_sample_delay</span><span class="p">,</span><span class="n">accumulation_time</span><span class="p">,</span><span class="n">shift_int</span><span class="p">,</span><span class="n">sideband</span><span class="p">)</span>
                                                <span class="n">str_print</span> <span class="o">=</span> <span class="n">pair_str</span><span class="o">+</span><span class="n">signal_chunk_fft_out</span>
                                                <span class="k">if</span> <span class="n">SILENT_OUTPUT</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                                                    <span class="nb">print</span><span class="p">(</span><span class="n">str_print</span><span class="p">)</span>
                                                <span class="k">else</span><span class="p">:</span>
                                                    <span class="n">count_print</span><span class="o">+=</span><span class="mi">1</span>
                                            <span class="k">else</span><span class="p">:</span> 
                                                
                                                <span class="c1"># Linear scaling stations</span>
                                                
                                                <span class="c1">#tot_tasks=tot_pols*tot_stations</span>
                                                <span class="n">index_task_col</span><span class="o">=</span><span class="n">station_id</span><span class="o">*</span><span class="n">tot_pols</span><span class="o">+</span><span class="n">mod_polarization_id</span>
                                                <span class="k">for</span> <span class="n">s0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">tot_stations</span><span class="p">):</span>
                                                    <span class="k">for</span> <span class="n">t0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">tot_pols</span><span class="p">):</span>
                                                        <span class="n">index_task_row</span><span class="o">=</span><span class="n">s0</span><span class="o">*</span><span class="n">tot_pols</span><span class="o">+</span><span class="n">t0</span>
                                                        <span class="k">if</span> <span class="p">(</span><span class="n">tasks_pairs</span><span class="p">[</span><span class="n">index_task_row</span><span class="p">][</span><span class="n">index_task_col</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">):</span>
                                                            <span class="n">pair</span><span class="o">=</span><span class="n">get_pair_linear_scaling</span><span class="p">(</span><span class="n">s0</span><span class="p">,</span><span class="n">t0</span><span class="p">)</span>
                                                            <span class="c1"># Char to identify mode</span>
                                                            <span class="n">char_p</span><span class="o">=</span><span class="s2">&quot;r&quot;</span>
                                                            <span class="n">pair_str</span> <span class="o">=</span> <span class="n">get_pair_str</span><span class="p">(</span><span class="n">char_p</span><span class="p">,</span><span class="n">pair</span><span class="p">,</span><span class="n">accu_block</span><span class="p">,</span><span class="n">mod_channel</span><span class="p">,</span>\
                                                                         <span class="n">num_channels_spec</span><span class="p">,</span><span class="n">accu_block</span><span class="p">,</span><span class="n">first_sample_signal</span><span class="p">,</span>\
                                                                         <span class="n">station_id</span><span class="p">,</span><span class="n">mod_polarization_id</span><span class="p">,</span>\
                                                                         <span class="n">freq_sample_in</span><span class="p">,</span><span class="n">bits_per_sample</span><span class="p">,</span><span class="n">data_type_chars</span><span class="p">[</span><span class="n">data_type</span><span class="p">],</span>\
                                                                         <span class="n">encoding</span><span class="p">,</span><span class="n">n_bins_pcal_val</span><span class="p">,</span><span class="n">pcal_freq</span><span class="p">,</span>\
                                                                         <span class="n">ONE_BASELINE_PER_TASK</span><span class="p">,</span><span class="n">TASK_SCALING_STATIONS</span><span class="p">,</span>\
                                                                         <span class="n">index_task_row</span><span class="p">,</span><span class="n">tot_stations</span><span class="o">*</span><span class="n">tot_pols</span><span class="p">,</span><span class="n">tot_accu_blocks</span><span class="p">,</span>\
                                                                         <span class="n">num_samples_in_chunk</span><span class="p">,</span><span class="n">abs_delay</span><span class="p">,</span><span class="n">rate_delay</span><span class="p">,</span><span class="n">freq_channel</span><span class="p">,</span>\
                                                                         <span class="n">fractional_sample_delay</span><span class="p">,</span><span class="n">accumulation_time</span><span class="p">,</span><span class="n">shift_int</span><span class="p">,</span><span class="n">sideband</span><span class="p">)</span>
                                                            <span class="n">str_print</span> <span class="o">=</span> <span class="n">pair_str</span><span class="o">+</span><span class="n">signal_chunk_fft_out</span>
                                                            <span class="nb">print</span><span class="p">(</span><span class="n">str_print</span><span class="p">)</span>
                                            
                                        <span class="k">else</span><span class="p">:</span>
                                        
                                            <span class="c1"># One-baseline-per-task</span>
                                            
                                            <span class="n">id_pair</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                                            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
                                                <span class="n">id_pair</span><span class="o">+=</span><span class="mi">1</span>
                                        
                                                <span class="c1"># If station-thread in pair:</span>
                                                <span class="c1">#TO DO: move fft and heavy computations here (after if) to avoid unnecessary processing...</span>
                                                <span class="k">if</span> <span class="p">(</span><span class="n">station_id</span><span class="o">==</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">mod_polarization_id</span><span class="o">==</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">station_id</span><span class="o">==</span><span class="n">pair</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="n">mod_polarization_id</span><span class="o">==</span><span class="n">pair</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
                    
                                                    <span class="c1"># keys</span>
                                                    <span class="n">char_p</span><span class="o">=</span><span class="s2">&quot;y&quot;</span>
                                                    <span class="n">pair_str</span> <span class="o">=</span> <span class="n">get_pair_str</span><span class="p">(</span><span class="n">char_p</span><span class="p">,</span><span class="n">pair</span><span class="p">,</span><span class="n">accu_block</span><span class="p">,</span><span class="n">mod_channel</span><span class="p">,</span><span class="n">num_channels_spec</span><span class="p">,</span>\
                                                                        <span class="n">accu_block</span><span class="p">,</span><span class="n">first_sample_signal</span><span class="p">,</span>\
                                                                        <span class="n">station_id</span><span class="p">,</span><span class="n">mod_polarization_id</span><span class="p">,</span>\
                                                                        <span class="n">freq_sample_in</span><span class="p">,</span><span class="n">bits_per_sample</span><span class="p">,</span><span class="n">data_type_chars</span><span class="p">[</span><span class="n">data_type</span><span class="p">],</span>\
                                                                        <span class="n">encoding</span><span class="p">,</span><span class="n">n_bins_pcal_val</span><span class="p">,</span><span class="n">pcal_freq</span><span class="p">,</span>\
                                                                        <span class="n">ONE_BASELINE_PER_TASK</span><span class="p">,</span><span class="n">TASK_SCALING_STATIONS</span><span class="p">,</span>\
                                                                        <span class="n">id_pair</span><span class="p">,</span><span class="n">tot_pairs</span><span class="p">,</span><span class="n">tot_accu_blocks</span><span class="p">,</span>\
                                                                        <span class="n">num_samples_in_chunk</span><span class="p">,</span><span class="n">abs_delay</span><span class="p">,</span><span class="n">rate_delay</span><span class="p">,</span><span class="n">freq_channel</span><span class="p">,</span>\
                                                                        <span class="n">fractional_sample_delay</span><span class="p">,</span><span class="n">accumulation_time</span><span class="p">,</span><span class="n">shift_int</span><span class="p">,</span><span class="n">sideband</span><span class="p">)</span>
                                                    <span class="n">str_print</span> <span class="o">=</span> <span class="n">pair_str</span><span class="o">+</span><span class="n">signal_chunk_fft_out</span>
                                                    <span class="nb">print</span><span class="p">(</span><span class="n">str_print</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">error_frame</span> <span class="o">=</span> <span class="n">C_M_READ_ERR_HEADER_NONE</span>
                <span class="n">keep_reading</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1">#print(&quot;zM&quot;+KEY_SEP+&quot;Invalid header or data for file &quot;+current_file_name)</span>
                <span class="k">if</span> <span class="n">read_rest</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">rest_reading</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                    <span class="k">except</span> <span class="ne">EOFError</span><span class="p">:</span>
                        <span class="n">error_reading_rest</span><span class="o">=</span><span class="mi">1</span>
                        <span class="c1">#print(&quot;zM&quot;+KEY_SEP+&quot;EOF reading rest of file &quot;+current_file_name)</span>
                
        

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Read input (to avoid errors) and exit</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">read_rest</span><span class="o">=</span><span class="mi">1</span>
            <span class="n">rest_reading</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">EOFError</span><span class="p">:</span>
            <span class="n">error_reading_rest</span><span class="o">=</span><span class="mi">1</span></div>
            <span class="c1">#print(&quot;zM&quot;+KEY_SEP+&quot;EOF reading rest of file &quot;+current_file_name)</span>

            
                        
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>

<span class="c1"># &lt;codecell&gt;</span>


</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Antonio Vazquez Alvarez, Victor Pankratius, and Pedro Elosegui.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>