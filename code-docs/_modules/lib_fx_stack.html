<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>lib_fx_stack &#8212; CorrelX 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for lib_fx_stack</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># &lt;nbformat&gt;3.0&lt;/nbformat&gt;</span>

<span class="c1"># &lt;codecell&gt;</span>

<span class="c1">#!/usr/bin/env python</span>
<span class="c1">#</span>
<span class="c1">#The MIT CorrelX Correlator</span>
<span class="c1">#</span>
<span class="c1">#https://github.com/MITHaystack/CorrelX</span>
<span class="c1">#Contact: correlX@haystack.mit.edu</span>
<span class="c1">#Project leads: Victor Pankratius, Pedro Elosegui Project developer: A.J. Vazquez Alvarez</span>
<span class="c1">#</span>
<span class="c1">#Copyright 2017 MIT Haystack Observatory</span>
<span class="c1">#</span>
<span class="c1">#Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</span>
<span class="c1">#</span>
<span class="c1">#The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</span>
<span class="c1">#</span>
<span class="c1">#THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#------------------------------</span>
<span class="c1">#------------------------------</span>
<span class="c1">#Project: CorrelX.</span>
<span class="c1">#File: lib_fx_stack.py.</span>
<span class="c1">#Author: A.J. Vazquez Alvarez (ajvazquez@haystack.mit.edu)</span>
<span class="c1">#Description: </span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">CorrelX FX correlation and samples-stack routines.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#History:</span>
<span class="c1">#initial version: 2016.10 ajva</span>
<span class="c1">#MIT Haystack Observatory</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span><span class="n">division</span>
<span class="kn">import</span> <span class="nn">scipy.fftpack</span> <span class="k">as</span> <span class="nn">scfft</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
<span class="kn">import</span> <span class="nn">imp</span>

<span class="kn">import</span> <span class="nn">const_mapred</span>
<span class="n">imp</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="n">const_mapred</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">const_mapred</span> <span class="k">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">lib_pcal</span>
<span class="n">imp</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="n">lib_pcal</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">lib_pcal</span> <span class="k">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">lib_delay_model</span>
<span class="n">imp</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="n">lib_delay_model</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">lib_delay_model</span> <span class="k">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">lib_debug</span>
<span class="n">imp</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="n">lib_debug</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">lib_debug</span> <span class="k">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">const_performance</span>
<span class="n">imp</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="n">const_performance</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">const_performance</span> <span class="k">import</span> <span class="o">*</span>


<span class="k">if</span> <span class="n">USE_FFTW</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pyfftw</span> 
    <span class="n">pyfftw</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
    <span class="c1">#pyfftw.interfaces.cache.set_keepalive_time(20)</span>
    

<span class="c1"># use numexpr</span>
<span class="k">if</span> <span class="n">USE_NE</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">numexpr</span> <span class="k">as</span> <span class="nn">ne</span>
    <span class="n">ne</span><span class="o">.</span><span class="n">set_num_threads</span><span class="p">(</span><span class="n">THREADS_NE</span><span class="p">)</span>

<span class="c1"># multiprocessing</span>
<span class="k">if</span> <span class="n">USE_MP</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">multiprocessing</span>
    
    

    
<span class="c1">###########################################</span>
<span class="c1">#           Samples stacking</span>
<span class="c1">########################################### </span>


<div class="viewcode-block" id="hstack_new_samples"><a class="viewcode-back" href="../lib_fx_stack.html#lib_fx_stack.hstack_new_samples">[docs]</a><span class="k">def</span> <span class="nf">hstack_new_samples</span><span class="p">(</span><span class="n">F1_partial</span><span class="p">,</span><span class="n">F_ind_partial</span><span class="p">,</span><span class="n">F_ind</span><span class="p">,</span><span class="n">F1</span><span class="p">,</span><span class="n">F_adj_shift_partial</span><span class="p">,</span><span class="n">F_stack_shift</span><span class="p">,</span><span class="n">F_lti_in</span><span class="p">,</span><span class="n">F_first_sample</span><span class="p">,</span>\
                       <span class="n">mode_str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">F_frac_over_ind</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Concatenation of new samples with previously saved.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     F1_partial</span>
<span class="sd">         previously saved samples.</span>
<span class="sd">     F_ind_partial</span>
<span class="sd">         identifiers for each row of saved samples.</span>
<span class="sd">     F_ind</span>
<span class="sd">         identifiers for rows of new samples.</span>
<span class="sd">     F1</span>
<span class="sd">         new samples.</span>
<span class="sd">     F_adj_shift_partial</span>
<span class="sd">         [unused] previously used for keeping track of the number of samples to add/drop, superseded by F_frac_over.</span>
<span class="sd">     F_refs</span>
<span class="sd">         indices for F1 based on F1_partial, used for other lists obtained in update_stored_samples(): (F_delay,F_rates,etc).</span>
<span class="sd">     F_stack_shift</span>
<span class="sd">         [unused] previously used to keep track of added/dropped samples.</span>
<span class="sd">     F_lti</span>
<span class="sd">         list with last sample (l), total number of samples processed (t), invalid samples (i), and adjuted samples for each stream.</span>
<span class="sd">     F_adj_shift_partial</span>
<span class="sd">         number of samples that have to be adjusted</span>
<span class="sd">     F_first_sample</span>
<span class="sd">         list with first sample corresponding to the streams in F1.</span>
<span class="sd">     mode_str</span>
<span class="sd">         &quot;f&quot; for normal operation model, &quot;pcal&quot; for saving the samples for phase calibration.</span>
<span class="sd">     F_frac_over</span>
<span class="sd">         list with the number of positions of the samples added/dropped due to fractional sample correction overflow,</span>
<span class="sd">                              see get_frac_over_ind() and fix_frac_over() for more details.</span>
<span class="sd">                              </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     F1_partial_out</span>
<span class="sd">         F1_partial with samples from F1 added.</span>
<span class="sd">     F_ind_partial_out</span>
<span class="sd">         station-polarization identifiers for the streams in F1_partial_out (same format as in keys).</span>
<span class="sd">     F_refs_out</span>
<span class="sd">         indices to F_frac etc structures based on F1_partial.</span>
<span class="sd">     F_stack_shift_out</span>
<span class="sd">         [unused] previously used to keep track of added/dropped samples.</span>
<span class="sd">     F_lti_out</span>
<span class="sd">         F_lti updated.</span>
<span class="sd">     F1_out</span>
<span class="sd">         Emtpy list of arrays.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    |</span>
<span class="sd">    | **Procedure:**</span>
<span class="sd">    |</span>
<span class="sd">    |  If there are stored samples, iterate over list of stored samples:</span>
<span class="sd">    |   1. [currently disabled] Add zero padding if first sample does not match the expected first sample number.</span>
<span class="sd">    |   2. Concatenate new samples (accesed at F1 via F_ref) with stored samples.</span>
<span class="sd">    |  Otherwise initialize structures and store new samples.</span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **Approximations:**</span>
<span class="sd">    |</span>
<span class="sd">    |  -Zero-padding currently disabled, new samples are simply stored. This due to the need to debug yet the offsets in the </span>
<span class="sd">    |    update of added/dropped samples from fix_frac_over(). Although these numbers are obtained in the mapper, there may</span>
<span class="sd">    |    be invalid frames that thus leave a gap.</span>
<span class="sd">    |  -It is not checked if the first sample number is lesser than the last sample stored, but this should not be necessary.</span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **Debugging:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Activate DEBUG_HSTACK for tabulated output of the concatenations.</span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **TO DO:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Group repeated code, and create functions for managing F_lti.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">F_lti</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">F_lti_in</span><span class="p">)</span>
    <span class="n">failed_hstack</span><span class="o">=</span><span class="mi">0</span>   
    <span class="n">F_stack_shift_out</span><span class="o">=</span><span class="n">F_stack_shift</span>
    <span class="n">reset_structures</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">F_ind_partial_out</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">F1_partial_out</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">F_lti_out</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">F_refs_out</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">F1</span><span class="p">)))</span> <span class="c1"># This is for indices to other structures, to avoid moving data</span>
    <span class="n">adjusted</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">F_ind</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">F_ind_partial</span><span class="p">))):</span>
        <span class="n">F_ind_partial_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="n">F1_partial_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">F_lti</span><span class="p">):</span>
            <span class="n">F_lti_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">F_lti</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">F_lti_out</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># last, total, invalid, adjusted</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">F_ind_partial</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">reset_structures</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#TO DO: resort if necessary based on F_ind and F_ind_partial, and check for errors</span>
        <span class="c1"># Currently simply checking that stored are new are equal, if not dismiss old data and take new</span>
        
        <span class="k">if</span> <span class="n">F_ind_partial</span><span class="o">!=</span><span class="p">[]:</span>
            <span class="k">if</span> <span class="n">F_ind_partial</span><span class="o">!=</span><span class="p">[]:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">F_ind</span><span class="p">)):</span>
                    
                    <span class="c1"># Check if missing data</span>
                    
                    <span class="n">tot_samples</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">F1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">last_sample</span><span class="o">=</span><span class="n">F_first_sample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">tot_samples</span>
                    <span class="c1"># There may be a different sorting due to delay correction...</span>
                    <span class="k">if</span> <span class="n">F_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">F_ind_partial</span><span class="p">:</span>
                        <span class="n">index_in_partial</span><span class="o">=</span><span class="n">F_ind_partial</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">F_ind</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        
                        
                        <span class="n">diff_first</span><span class="o">=</span><span class="n">F_first_sample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="p">(</span><span class="n">F_lti_out</span><span class="p">[</span><span class="n">index_in_partial</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                        <span class="c1"># TO DO: they should be equal, add check for other inequality</span>
                        
                        <span class="n">offset_frac</span><span class="o">=</span><span class="mi">0</span>
                        <span class="k">if</span> <span class="n">F_frac_over_ind</span><span class="o">!=</span><span class="p">[]:</span>
                            <span class="n">offset_frac</span><span class="o">=</span><span class="n">F_frac_over_ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                            <span class="c1">#diff_first-=offset_frac</span>
                            <span class="c1">#diff_first-=F_lti[index_in_partial][3]</span>
                            
                        <span class="n">F_lti_out</span><span class="p">[</span><span class="n">index_in_partial</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">+=</span><span class="n">offset_frac</span>
                        
                        
                        <span class="c1">##if diff_first&gt;0:</span>
                        <span class="c1">## TO DO: disabled padding for missing samples...</span>
                        <span class="c1">#    # Missing samples</span>
                        <span class="c1">#    F1_partial_out[index_in_partial]=np.hstack((F1_partial[index_in_partial],np.zeros(diff_first,dtype=complex),F1[i]))</span>
                        <span class="c1">#    F_lti_out[index_in_partial][2]+=diff_first</span>
                        <span class="c1">#    print(&quot;zR\Warning: Inserted &quot;+str(diff_first)+&quot; samples at ls &quot;+str(last_sample)+&quot; for st &quot;+str(F_ind[i]))</span>
                        <span class="c1">#else:</span>
                        
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">F1_partial_out</span><span class="p">[</span><span class="n">index_in_partial</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">F1_partial</span><span class="p">[</span><span class="n">index_in_partial</span><span class="p">],</span><span class="n">F1</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Failed hstack &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">F_first_sample</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                            <span class="n">failed_hstack</span><span class="o">=</span><span class="mi">1</span>
                        
                        <span class="n">F_ind_partial_out</span><span class="p">[</span><span class="n">index_in_partial</span><span class="p">]</span><span class="o">=</span><span class="n">F_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">F_refs_out</span><span class="p">[</span><span class="n">index_in_partial</span><span class="p">]</span><span class="o">=</span><span class="n">i</span>
                        
                        <span class="k">if</span> <span class="n">DEBUG_HSTACK</span><span class="p">:</span>
                            <span class="n">print_debug_r_hstack</span><span class="p">(</span><span class="n">mode_str</span><span class="p">,</span><span class="n">index_in_partial</span><span class="p">,</span><span class="n">F_ind_partial</span><span class="p">[</span><span class="n">index_in_partial</span><span class="p">],</span>\
                                                 <span class="n">F_ind_partial_out</span><span class="p">[</span><span class="n">index_in_partial</span><span class="p">],</span><span class="n">i</span><span class="p">,</span><span class="n">F_ind</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        
                        <span class="n">F_lti_out</span><span class="p">[</span><span class="n">index_in_partial</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">last_sample</span>
                        <span class="n">F_lti_out</span><span class="p">[</span><span class="n">index_in_partial</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="n">tot_samples</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># new record</span>
                        <span class="n">diff_first</span><span class="o">=</span><span class="n">F_first_sample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="p">(</span><span class="n">F_lti_out</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">offset_frac</span><span class="o">=</span><span class="mi">0</span>
                        <span class="k">if</span> <span class="n">F_frac_over_ind</span><span class="o">!=</span><span class="p">[]:</span>
                            <span class="n">offset_frac</span><span class="o">=</span><span class="n">F_frac_over_ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                            <span class="c1">#diff_first-=offset_frac</span>
                            <span class="c1"># This record does not exist yet</span>
                            <span class="c1">#diff_first-=F_lti[i][3]</span>
                        
                        <span class="n">F_lti_out</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">+=</span><span class="n">offset_frac</span>
                        
                        <span class="c1">##if diff_first&gt;0:</span>
                        <span class="c1">## HARDCODED: disabled padding...</span>
                        <span class="c1">#    F1_partial_out[i]=np.hstack((np.zeros(diff_first,dtype=complex),F1[i]))</span>
                        <span class="c1">#    F_lti_out[i][2]+=diff_first</span>
                        <span class="c1">#    #F_lti_out[i][3]+=offset_frac</span>
                        <span class="c1">#    print(&quot;zR\Warning: Inserted &quot;+str(diff_first)+&quot; samples at ls &quot;+str(last_sample)+&quot; for st &quot;+str(F_ind[i]))</span>
                        <span class="c1">#else:</span>
                        
                        <span class="n">F1_partial_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">F1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        
                        <span class="n">F_ind_partial_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">F_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">F_refs_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">i</span>
                
                        <span class="k">if</span> <span class="n">DEBUG_HSTACK</span><span class="p">:</span>
                            <span class="n">print_debug_r_hstack</span><span class="p">(</span><span class="n">mode_str</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">F_ind_partial</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">F_ind_partial_out</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">i</span><span class="p">,</span><span class="n">F_ind</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    
                        <span class="n">F_lti_out</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">last_sample</span>
                        <span class="n">F_lti_out</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="n">tot_samples</span>
                        <span class="c1">#if F_frac_over_ind!=[]:</span>
                        <span class="c1">#    F_lti_out[index_in_partial][3]=offset_frac</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">reset_structures</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reset_structures</span><span class="o">=</span><span class="mi">1</span>
    
    

    
    <span class="n">tried</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">if</span> <span class="n">DEBUG_FRAC_OVER</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zR&quot;</span><span class="o">+</span><span class="n">KEY_SEP</span><span class="o">+</span><span class="s2">&quot;oai&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">F_stack_shift</span><span class="p">))</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">F_adj_shift_partial</span><span class="p">))</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zR&quot;</span><span class="o">+</span><span class="n">KEY_SEP</span><span class="o">+</span><span class="s2">&quot;oi&quot;</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;  &quot;</span><span class="o">+</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="n">F_stack_shift</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;  &quot;</span><span class="o">+</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="n">F_adj_shift_partial</span><span class="p">)))</span>
    <span class="c1"># TO DO: this needs to be checked</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">F_stack_shift</span><span class="p">)</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">F_adj_shift_partial</span><span class="p">):</span>
        <span class="n">F_stack_shift_out</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">F_adj_shift_partial</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">DEBUG_FRAC_OVER</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zR&quot;</span><span class="o">+</span><span class="n">KEY_SEP</span><span class="o">+</span><span class="s2">&quot;o T=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">tried</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;,A=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">adjusted</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">reset_structures</span><span class="p">:</span>
        
        <span class="c1">#F1_partial_out=F1[:]</span>
        <span class="n">F_lti_out</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">F1</span><span class="p">)):</span>
            <span class="n">F_lti_out</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">offset_frac</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">if</span> <span class="n">F_frac_over_ind</span><span class="o">!=</span><span class="p">[]:</span>
                <span class="n">offset_frac</span><span class="o">=</span><span class="n">F_frac_over_ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">F_lti_out</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="n">offset_frac</span>
            <span class="n">tot_samples</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">F1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="n">last_sample</span><span class="o">=</span><span class="n">F_first_sample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">tot_samples</span>
            
            <span class="n">diff_first</span><span class="o">=</span><span class="n">F_first_sample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="p">(</span><span class="n">F_lti_out</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            
            <span class="c1">##if diff_first&gt;0:</span>
            <span class="c1">#if 1==0:</span>
            <span class="c1">#    F1_partial_out[i]=np.hstack((np.zeros(diff_first,dtype=complex),F1[i]))</span>
            <span class="c1">#    F_lti_out[i][2]+=diff_first</span>
            <span class="c1">#else:</span>
            
            <span class="n">F1_partial_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">F1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            
            <span class="n">F_ind_partial_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">F_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">F_refs_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">i</span>
            
            <span class="n">F_lti_out</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">last_sample</span>
            <span class="n">F_lti_out</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="n">tot_samples</span>
            
            <span class="k">if</span> <span class="n">DEBUG_HSTACK</span><span class="p">:</span>
                <span class="n">print_debug_r_hstack</span><span class="p">(</span><span class="n">mode_str</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="n">F_ind_partial_out</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">i</span><span class="p">,</span><span class="n">F_ind</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">F_stack_shift_out</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">F_ind_partial_out</span><span class="p">)</span>
        <span class="c1">#F_ind_partial_out=F_ind[:]</span>
        <span class="c1">#F_refs_out=list(range(len(F1)))</span>
        <span class="c1">#if (F_stack_shift!=[])and(F_adj_shift_partial!=[]):</span>
        <span class="c1">#    F_stack_shift_out=F_adj_shift_partial[:]</span>
        <span class="c1">#else:</span>
        <span class="c1">#    F_stack_shift_out=[0]*len(F_adj_shift_partial)</span>

    <span class="k">if</span> <span class="n">DEBUG_FRAC_OVER</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zR&quot;</span><span class="o">+</span><span class="n">KEY_SEP</span><span class="o">+</span><span class="s2">&quot;oao&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">F_stack_shift_out</span><span class="p">))</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">F_adj_shift_partial</span><span class="p">))</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">DEBUG_HSTACK</span><span class="p">:</span>
        <span class="n">print_debug_r_hstack_arrow</span><span class="p">(</span><span class="n">F1_partial</span><span class="p">,</span><span class="n">F1</span><span class="p">,</span><span class="n">F1_partial_out</span><span class="p">,</span><span class="n">F_lti_out</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">DEBUG_HSTACK</span><span class="p">:</span>
        <span class="n">print_debug_r_hstack_separator</span><span class="p">()</span>
        
    <span class="c1">#if mode_str==&quot;f&quot;:</span>
    <span class="c1"># reset F1</span>
    <span class="n">len_F1</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">F1</span><span class="p">)</span>
    <span class="n">F1_out</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">len_F1</span><span class="p">):</span>
        <span class="n">F1_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>
      
    
    <span class="k">return</span><span class="p">([</span><span class="n">F1_partial_out</span><span class="p">,</span><span class="n">F_ind_partial_out</span><span class="p">,</span><span class="n">F_refs_out</span><span class="p">,</span><span class="n">F_stack_shift_out</span><span class="p">,</span><span class="n">F_lti_out</span><span class="p">,</span><span class="n">F1_out</span><span class="p">])</span></div>




<span class="c1">###########################################</span>
<span class="c1">#        Fractional sample overflow</span>
<span class="c1">########################################### </span>


<div class="viewcode-block" id="get_frac_over_ind"><a class="viewcode-back" href="../lib_fx_stack.html#lib_fx_stack.get_frac_over_ind">[docs]</a><span class="k">def</span> <span class="nf">get_frac_over_ind</span><span class="p">(</span><span class="n">F_first_sample</span><span class="p">,</span><span class="n">F1</span><span class="p">,</span><span class="n">F_rates</span><span class="p">,</span><span class="n">F_fs</span><span class="p">,</span><span class="n">F_ind</span><span class="p">,</span><span class="n">F_side</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get locations of samples to be added/dropped due to fractional bit shift.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     F_first_sample</span>
<span class="sd">         list with the first sample number for each vector of data.</span>
<span class="sd">     F1</span>
<span class="sd">         list of vectors with new data for each stpol (only lengths are read).</span>
<span class="sd">     F_rates</span>
<span class="sd">         model/clock delay information for computing delays.</span>
<span class="sd">     F_fs</span>
<span class="sd">         sampling frequency for each vector with new data.</span>
<span class="sd">     F_ind</span>
<span class="sd">         list with identifiers for stations (for logging).</span>
<span class="sd">     F_side</span>
<span class="sd">         list with sidebands</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     F_frac_over_ind</span>
<span class="sd">         list of [number_of_samples_to_be_added_or_dropped,[list_of_locations_for_these_changes]] for each element in F1.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    |</span>
<span class="sd">    | **Algorithm:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Compute integer+fractional sample delay at both extremes of the vector with data, then find intersection</span>
<span class="sd">    |   with changes in fractional delay (given a fractional sample correction between 0 and 1, it checks for crossing at 0.5).</span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **Debugging:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Activate DEBUG_FRAC_OVER for tabulated output of the fractional overflow corrections.</span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **TO DO:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Add support for multiple samples.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">F_frac_over_ind</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">F1</span><span class="p">)):</span>
        <span class="n">fs</span><span class="o">=</span><span class="n">F_fs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">Ts</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">fs</span>
        <span class="p">[</span><span class="n">sideband</span><span class="p">,</span><span class="n">data_type</span><span class="p">]</span><span class="o">=</span><span class="n">F_side</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="c1">#sample0=F_first_sample[F_refs[stpol]]-len(F1[F_refs[stpol]])</span>
        <span class="n">first_sample</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">F_first_sample</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">num_samples</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">F1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">timescale</span><span class="o">=</span><span class="n">Ts</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">first_sample</span><span class="p">,</span><span class="n">first_sample</span><span class="o">+</span><span class="n">num_samples</span><span class="p">])</span>

        <span class="p">[</span><span class="n">delay_rate_0</span><span class="p">,</span><span class="n">delay_rate_1</span><span class="p">,</span><span class="n">delay_rate_2</span><span class="p">,</span><span class="n">delay_rate_ref</span><span class="p">,</span><span class="n">clock_rate_0</span><span class="p">,</span>\
               <span class="n">clock_rate_1</span><span class="p">,</span><span class="n">clock_abs_rate_0</span><span class="p">,</span><span class="n">clock_abs_rate_1</span><span class="p">,</span><span class="n">clock_rate_ref</span><span class="p">,</span>\
               <span class="n">model_only_delay</span><span class="p">,</span><span class="n">clock_only_delay</span><span class="p">,</span><span class="n">diff_frac</span><span class="p">]</span><span class="o">=</span><span class="n">F_rates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1">#diff_frac=0</span>

        <span class="n">clock_diff</span> <span class="o">=</span> <span class="p">[</span><span class="n">clock_rate_0</span><span class="p">,</span><span class="n">clock_rate_1</span><span class="p">]</span>
        <span class="n">poly_diff</span> <span class="o">=</span> <span class="p">[</span><span class="n">delay_rate_0</span><span class="p">,</span><span class="n">delay_rate_1</span><span class="p">,</span><span class="n">delay_rate_2</span><span class="p">]</span>
        <span class="n">clock_abs</span> <span class="o">=</span> <span class="p">[</span><span class="n">clock_abs_rate_0</span><span class="p">,</span><span class="n">clock_abs_rate_1</span><span class="p">]</span>
        

        <span class="n">seconds_offset</span><span class="o">=</span><span class="mi">0</span>

        <span class="p">[</span><span class="n">r_recalc</span><span class="p">,</span><span class="n">m_unused</span><span class="p">,</span><span class="n">c_recalc</span><span class="p">,</span><span class="n">r_unused</span><span class="p">,</span><span class="n">a_unused</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_delay_val</span><span class="p">(</span>\
                       <span class="n">clock_diff</span><span class="o">=</span><span class="n">clock_diff</span><span class="p">,</span>\
                       <span class="n">poly_diff</span><span class="o">=</span><span class="n">poly_diff</span><span class="p">,</span>\
                       <span class="n">seconds_ref_clock</span><span class="o">=</span><span class="n">clock_rate_ref</span><span class="p">,</span>\
                       <span class="n">seconds_ref_poly</span><span class="o">=</span><span class="n">delay_rate_ref</span><span class="p">,</span>\
                       <span class="n">seconds</span><span class="o">=</span><span class="n">timescale</span><span class="p">,</span>\
                       <span class="n">seconds_offset</span><span class="o">=</span><span class="n">seconds_offset</span><span class="p">,</span>\
                       <span class="n">v</span><span class="o">=</span><span class="n">DEBUG_LIB_DELAY</span><span class="p">,</span><span class="n">diff_pol</span><span class="o">=</span><span class="n">DIFF_POLY</span><span class="p">)</span>
        
        
        <span class="p">[</span><span class="n">full_fractional_recalc_f</span><span class="p">,</span><span class="n">fractional_recalc_f</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_full_frac_val</span><span class="p">(</span><span class="n">r_recalc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">fs</span><span class="p">,</span><span class="n">bypass_correction</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">[</span><span class="n">full_fractional_recalc_l</span><span class="p">,</span><span class="n">fractional_recalc_l</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_full_frac_val</span><span class="p">(</span><span class="n">r_recalc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">fs</span><span class="p">,</span><span class="n">bypass_correction</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">r_shift_v</span><span class="o">=</span><span class="p">[</span><span class="n">fractional_recalc_f</span><span class="p">,</span><span class="n">fractional_recalc_l</span><span class="p">]</span>
        <span class="c1"># TO DO: fix this</span>
        <span class="n">r_shift_v_int</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">r_shift_v</span><span class="p">)</span>
        <span class="n">delta_shift</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">delta_shift_frac</span><span class="o">=</span><span class="mi">0</span>
        
        <span class="c1"># TO DO: check this</span>
        <span class="k">if</span> <span class="n">r_shift_v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;=</span><span class="mf">0.5</span> <span class="ow">and</span> <span class="n">r_shift_v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mf">0.5</span> <span class="ow">and</span> <span class="n">poly_diff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">delta_shift</span><span class="o">=</span><span class="mi">1</span>
            <span class="c1">#delta_shift=-1</span>
        <span class="k">elif</span> <span class="n">r_shift_v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;=</span><span class="mf">0.5</span> <span class="ow">and</span> <span class="n">r_shift_v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="mf">0.5</span> <span class="ow">and</span> <span class="n">poly_diff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">delta_shift</span><span class="o">=-</span><span class="mi">1</span>
            <span class="c1">#delta_shift=1</span>
        <span class="c1">#elif full_fractional_recalc_f//1 != full_fractional_recalc_l//1:</span>
        <span class="c1">#    print(&quot;Warning: change in sample not taken into account!&quot;)</span>
        
        <span class="c1">#if delta_shift!=0:</span>
        <span class="c1">#    if sideband==&#39;L&#39;:</span>
        <span class="c1">#        delta_shift=-delta_shift</span>
        

        <span class="n">delta_shift_frac</span><span class="o">=</span><span class="n">r_shift_v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">r_shift_v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">delta_shift</span><span class="o">&gt;</span><span class="n">num_samples</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zR\Warning: frac - delta shift too high: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">delta_shift</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; for &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span><span class="o">+</span>\
                  <span class="s2">&quot; samples, skipping frac shift at first sample &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">first_sample</span><span class="p">))</span>
            <span class="n">delta_shift</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">shift_v</span><span class="o">=</span><span class="p">[]</span>

        <span class="k">if</span> <span class="n">delta_shift</span><span class="o">==</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">delta_shift</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">shift_v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="mf">0.5</span><span class="o">-</span><span class="n">r_shift_v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="nb">float</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">delta_shift_frac</span><span class="p">)))))</span>
        <span class="k">elif</span> <span class="n">delta_shift</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i_d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">delta_shift</span><span class="p">)):</span>
                <span class="c1"># Linear approx., intersection with 0.5</span>
                <span class="n">x</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="o">-</span><span class="n">r_shift_v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="nb">float</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">delta_shift_frac</span><span class="p">))</span>
                <span class="n">x</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="n">shift_v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
       
        <span class="k">if</span> <span class="n">DIFF_POLY</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">delta_shift</span><span class="o">=-</span><span class="n">delta_shift</span>
            
                
        <span class="n">F_frac_over_ind</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">delta_shift</span><span class="p">,</span><span class="n">shift_v</span><span class="p">])</span> 
    
        <span class="n">fractional_sample_correction</span><span class="o">=</span><span class="mi">0</span>
    
    
    <span class="c1">#if DEBUG_FRAC_OVER:</span>
    <span class="c1">#    print(&quot;zR&quot;+KEY_SEP+&quot;getfr: &quot;+str(F_first_sample)+&quot; &quot;+str(F_frac_over_ind))</span>
    
    
    
    <span class="k">return</span><span class="p">(</span><span class="n">F_frac_over_ind</span><span class="p">)</span></div>




<div class="viewcode-block" id="fix_frac_over"><a class="viewcode-back" href="../lib_fx_stack.html#lib_fx_stack.fix_frac_over">[docs]</a><span class="k">def</span> <span class="nf">fix_frac_over</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span><span class="n">F_frac_over_ind</span><span class="p">,</span><span class="n">F_ind</span><span class="p">,</span><span class="n">F_first_sample</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add or drop samples for overflow in fractional sample correction based on info from get_frac_over_ind().</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     F1</span>
<span class="sd">         list of vectors with new data.</span>
<span class="sd">     F_frac_over</span>
<span class="sd">         structure obtained in get_frac_over_ind() with locations of samples to be added/dropped.</span>
<span class="sd">     F_ind</span>
<span class="sd">         list of stpols corresponding to F1 (only for logging).</span>
<span class="sd">     F_first_sample</span>
<span class="sd">         list of first sample number to F1 (only for logging).</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     F1</span>
<span class="sd">         modified list of vectors with new data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fixed_frac</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">F_frac_over_ind</span><span class="p">)):</span>
        <span class="n">update_samp</span><span class="o">=</span><span class="n">F_frac_over_ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">v_ind</span><span class="o">=</span><span class="n">F_frac_over_ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">update_samp</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fixed_frac</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">DEBUG_GENERAL_R</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zR</span><span class="se">\t</span><span class="s2">Fixing frac: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">F_ind</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">F_first_sample</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">F_frac_over_ind</span><span class="p">))</span>
            <span class="n">fixed_frac</span><span class="o">=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">update_samp</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_ind</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">F1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">F1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">v_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">F1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">F1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">v_ind</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_ind</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">F1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">F1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">v_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">F1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">F1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">v_ind</span><span class="p">,[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">v_ind</span><span class="p">))</span>
    <span class="c1">#if fixed_frac:</span>
    <span class="c1">#    print(&quot;zR\tFixed frac: &quot;+str(F_ind)+&quot; &quot;+str(F_first_sample)+&quot; &quot;+str(F_frac_over_ind))</span>

    <span class="k">return</span><span class="p">(</span><span class="n">F1</span><span class="p">)</span></div>



<span class="c1">###########################################</span>
<span class="c1">#             Exponential</span>
<span class="c1">########################################### </span>



<div class="viewcode-block" id="get_exp"><a class="viewcode-back" href="../lib_fx_stack.html#lib_fx_stack.get_exp">[docs]</a><span class="k">def</span> <span class="nf">get_exp</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get exponential based on fractional part of input, see Output below for details.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     x : numpy array of float.</span>
<span class="sd">     </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     y : 1D numpy array of complex</span>
<span class="sd">         complex rotation (exponential of 2*j*pi*fractional_part(x))</span>
<span class="sd">     nr : bool</span>
<span class="sd">         do not rotate (1 if all elements in y are 1, 0 otherwise)</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    |</span>
<span class="sd">    | **Precision:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Integer part is removed to avoid problems with precision, rotation (j2pi).</span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **Approximations:**</span>
<span class="sd">    |</span>
<span class="sd">    |  -numpy.exp is not called in the trivial cases.</span>
<span class="sd">    | -IMPORTANT!: For arrays of more than 1 element, if the first, second and last elements are equal to zero, then</span>
<span class="sd">    |      all the elements are assumed to be zero too. Need to replace this by some check on the polynomial.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nr</span><span class="o">=</span><span class="mi">0</span>
    
    <span class="c1"># Check if it is only one element</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        
        <span class="c1"># Check if no rotation</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span>
            <span class="n">nr</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">USE_NE_EXP</span><span class="p">:</span>
                <span class="n">modf_val</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">modf</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">pi_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">y</span><span class="o">=</span><span class="n">ne</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s2">&quot;exp(1j*2*pi_val*modf_val)&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">modf</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
           
    
    <span class="c1"># (!) Check if first, second and last sample are equal, if so, compute only once and repeat</span>
    <span class="c1"># TO DO: check this approach</span>
    <span class="k">elif</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1"># Check if no rotation</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span>
            <span class="n">nr</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">USE_NE_EXP</span><span class="p">:</span>
                <span class="n">modf_val</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">modf</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">pi_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">y</span><span class="o">=</span><span class="n">ne</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s2">&quot;exp(1j*2*pi_val*modf_val)&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">modf</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
            
    
    <span class="c1"># Otherwise compute for all samples</span>
    <span class="c1">#return(np.exp(1j*2*np.pi*np.modf(np.float64(x))[0]))</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">USE_NE_EXP</span><span class="p">:</span>
            <span class="n">modf_val</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">modf</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">pi_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">y</span><span class="o">=</span><span class="n">ne</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s2">&quot;exp(1j*2*pi_val*modf_val)&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">modf</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">nr</span><span class="o">=</span><span class="mi">0</span>

    <span class="k">return</span><span class="p">([</span><span class="n">y</span><span class="p">,</span><span class="n">nr</span><span class="p">])</span></div>
    <span class="c1">#return(np.exp(1j*2*np.pi*np.modf(x)[0]))</span>



<div class="viewcode-block" id="get_rotator"><a class="viewcode-back" href="../lib_fx_stack.html#lib_fx_stack.get_rotator">[docs]</a><span class="k">def</span> <span class="nf">get_rotator</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get a single complex rotator from a list of rotators.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     x : list of complex.</span>
<span class="sd">     </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     rotator</span>
<span class="sd">         product of the elements in x.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">     TO DO: consider removing, devised to apply many rotators, but no longer needed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rotator</span><span class="o">=</span><span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">rotator</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">rotator</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">rotator</span><span class="p">)</span></div>



<span class="c1">###########################################</span>
<span class="c1">#           FX correlation</span>
<span class="c1">########################################### </span>



<div class="viewcode-block" id="window_and_fft"><a class="viewcode-back" href="../lib_fx_stack.html#lib_fx_stack.window_and_fft">[docs]</a><span class="k">def</span> <span class="nf">window_and_fft</span><span class="p">(</span><span class="n">v1_dequant</span><span class="p">,</span><span class="n">fft_size</span><span class="p">,</span><span class="n">windowing</span><span class="p">,</span><span class="n">flatten_chunks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">dtype_complex</span><span class="o">=</span><span class="nb">complex</span><span class="p">,</span><span class="n">rfft_data_type</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply window and do FFT of set of samples, to be grouped into chunks of FFT size.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     v1_dequant</span>
<span class="sd">         numpy arrays with complex samples in the time domain (fringe rotation already applied to them).</span>
<span class="sd">     fft_size</span>
<span class="sd">         number of coefficients in the FFT.</span>
<span class="sd">     windowing</span>
<span class="sd">         shape of the window to be applied prior to FFT, square by default.</span>
<span class="sd">     flatten_chunks</span>
<span class="sd">         1 if one-baseline-per-task mode, otherwise all-baselines-per-task.</span>
<span class="sd">     dtype_complex</span>
<span class="sd">         complex type to be used in initialization of arrays.</span>
<span class="sd">     rfft_data_type</span>
<span class="sd">         [unused] initially devised to use rfft, currently not used.</span>
<span class="sd">     </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     v1_fft</span>
<span class="sd">         numpy array of arrays, with as many rows as the ratio between number of samples and fft_size (forced to</span>
<span class="sd">                       be integer), and as many columns of fft_size.</span>
<span class="sd">                       </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    |</span>
<span class="sd">    | **Performance:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Using scipy fft, which yielded the highest performance on preliminary benchmarking with single thread reducer.</span>
<span class="sd">    |  PyFFTW implemented, but needs to be tested and benchmarked.</span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **TO DO: **</span>
<span class="sd">    |</span>
<span class="sd">    |  Add a more elegant implementation for windowing, and add more windows.</span>
<span class="sd">    |  Currently no windowing by default, may need to migrate functionality from this to windowing modes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
                   
    <span class="n">num_chunks1</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">v1_dequant</span><span class="p">)</span><span class="o">//</span><span class="n">fft_size</span>
    <span class="n">len_v1_dequant</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">v1_dequant</span><span class="p">)</span>
    <span class="n">v1_dequant</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">v1_dequant</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">flatten_chunks</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="c1"># One-baseline-per-task </span>
        <span class="c1"># Windowing:</span>
        <span class="k">if</span> <span class="n">windowing</span><span class="o">==</span><span class="n">C_INI_CR_WINDOW_HANNING</span><span class="p">:</span>
            <span class="c1"># -Hanning</span>
            <span class="k">if</span> <span class="n">num_chunks1</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">window_v1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">fft_size</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">rfft_data_type</span><span class="o">==</span><span class="s1">&#39;c&#39;</span><span class="p">:</span>
                    <span class="n">v1fft</span><span class="o">=</span><span class="p">[</span><span class="n">scfft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">v1_dequant</span><span class="p">,</span><span class="n">window_v1</span><span class="p">))]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">v1fft</span><span class="o">=</span><span class="p">[</span><span class="n">scfft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">v1_dequant</span><span class="p">,</span><span class="n">window_v1</span><span class="p">))]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">window_v1</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">fft_size</span><span class="p">)]</span><span class="o">*</span><span class="n">num_chunks1</span>
                <span class="k">if</span> <span class="n">rfft_data_type</span><span class="o">==</span><span class="s1">&#39;c&#39;</span><span class="p">:</span>
                    <span class="n">v1fft</span><span class="o">=</span><span class="n">scfft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v1_dequant</span><span class="p">,(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">fft_size</span><span class="p">)),</span><span class="n">window_v1</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">v1fft</span><span class="o">=</span><span class="n">scfft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v1_dequant</span><span class="p">,(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">fft_size</span><span class="p">)),</span><span class="n">window_v1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># -Square</span>
            <span class="k">if</span> <span class="n">num_chunks1</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">v1fft</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="k">elif</span> <span class="n">num_chunks1</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">USE_FFTW</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">rfft_data_type</span><span class="o">==</span><span class="s1">&#39;c&#39;</span><span class="p">:</span>
                        <span class="n">v1fft</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">scfft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">v1_dequant</span><span class="p">)])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">v1fft</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">scfft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">v1_dequant</span><span class="p">)])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fftw_input</span> <span class="o">=</span> <span class="n">pyfftw</span><span class="o">.</span><span class="n">empty_aligned</span><span class="p">(</span><span class="n">v1_dequant</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype_complex</span><span class="p">)</span>
                    <span class="n">fftw_input</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">v1_dequant</span>
                    <span class="n">v1fft</span> <span class="o">=</span> <span class="n">pyfftw</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">numpy_fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">fftw_input</span><span class="p">,</span><span class="n">threads</span><span class="o">=</span><span class="n">THREADS_FFTW</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">reshaped_dequant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v1_dequant</span><span class="p">,(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">fft_size</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">USE_FFTW</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">rfft_data_type</span><span class="o">==</span><span class="s1">&#39;c&#39;</span><span class="p">:</span>
                        <span class="n">v1fft</span><span class="o">=</span><span class="n">scfft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">reshaped_dequant</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">v1fft</span><span class="o">=</span><span class="n">scfft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">reshaped_dequant</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>    
                    <span class="n">fftw_input</span> <span class="o">=</span> <span class="n">pyfftw</span><span class="o">.</span><span class="n">empty_aligned</span><span class="p">(</span><span class="n">reshaped_dequant</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype_complex</span><span class="p">)</span>
                    <span class="n">fftw_input</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">reshaped_dequant</span>
                    <span class="n">v1fft</span> <span class="o">=</span> <span class="n">pyfftw</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">numpy_fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">fftw_input</span><span class="p">,</span><span class="n">threads</span><span class="o">=</span><span class="n">THREADS_FFTW</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#TO DO: windowing untested for not flattened chunks (used if all baselines in same task)</span>
        <span class="c1">#if windowing==C_INI_CR_WINDOW_HANNING:</span>
        <span class="c1">#    window_v1=[np.hanning(fft_size)]*num_chunks1</span>
        <span class="c1">#    v1fft=fft(np.multiply(np.reshape(v1_dequant,(-1,fft_size)),window_v1))</span>
        <span class="c1">#else:</span>
        <span class="c1">#print(v1_dequant.shape[1])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v1_dequant</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="n">fft_size</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">v1fft</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TO DO: need to reshape, but based on ordering of first samples (currently padding sample number in key...)</span>
            <span class="n">reshaped_dequant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v1_dequant</span><span class="p">,(</span><span class="n">len_v1_dequant</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">fft_size</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">USE_FFTW</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rfft_data_type</span><span class="o">==</span><span class="s1">&#39;c&#39;</span><span class="p">:</span>
                    <span class="n">v1fft</span><span class="o">=</span><span class="n">scfft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">reshaped_dequant</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">v1fft</span><span class="o">=</span><span class="n">scfft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">reshaped_dequant</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fftw_input</span> <span class="o">=</span> <span class="n">pyfftw</span><span class="o">.</span><span class="n">empty_aligned</span><span class="p">(</span><span class="n">reshaped_dequant</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype_complex</span><span class="p">)</span>
                <span class="n">fftw_input</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">reshaped_dequant</span>
                <span class="n">v1fft</span> <span class="o">=</span> <span class="n">pyfftw</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">scipy_fftpack</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">fftw_input</span><span class="p">,</span><span class="n">threads</span><span class="o">=</span><span class="n">THREADS_FFTW</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">v1fft</span><span class="p">)</span></div>


<div class="viewcode-block" id="multiply_accumulate"><a class="viewcode-back" href="../lib_fx_stack.html#lib_fx_stack.multiply_accumulate">[docs]</a><span class="k">def</span> <span class="nf">multiply_accumulate</span><span class="p">(</span><span class="n">accu_prod</span><span class="p">,</span><span class="n">v1fft</span><span class="p">,</span><span class="n">v2fft</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    [Only used in one-baseline-per-task mode.]</span>
<span class="sd">    Multiply and accumulate two ffts (one for each station).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">accu_prod</span><span class="o">==</span><span class="p">[]:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v1fft</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">accu_prod</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">v1fft</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">v2fft</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">accu_prod</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">v1fft</span><span class="p">,</span><span class="n">v2fft</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v1fft</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">accu_prod</span><span class="o">+=</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">v1fft</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">v2fft</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">accu_prod</span><span class="o">+=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">v1fft</span><span class="p">,</span><span class="n">v2fft</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">accu_prod</span><span class="p">)</span></div>




<div class="viewcode-block" id="normalize_mat"><a class="viewcode-back" href="../lib_fx_stack.html#lib_fx_stack.normalize_mat">[docs]</a><span class="k">def</span> <span class="nf">normalize_mat</span><span class="p">(</span><span class="n">acc_mat</span><span class="p">,</span><span class="n">count_acc</span><span class="p">,</span><span class="n">using_autocorrs</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalice results in accumulation matrix.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     acc_mat</span>
<span class="sd">         accumulation matrix (see compute_x_all for the definition of the matrix).</span>
<span class="sd">     count_acc</span>
<span class="sd">         number of accumulations.</span>
<span class="sd">     using_autocorrs</span>
<span class="sd">         1 by default, normalization using auto-correlations.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     acc_mat_out</span>
<span class="sd">         normalized accumulation matrix.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    |</span>
<span class="sd">    | **Known issues:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Need to check scaling.</span>
<span class="sd">    |</span>
<span class="sd">    | **TO DO:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Take into account valid samples!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bypass_normalize</span><span class="o">=</span><span class="mi">0</span>

    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">bypass_normalize</span><span class="p">):</span>
        <span class="n">acc_mat_norm</span><span class="o">=</span><span class="n">acc_mat</span>
        <span class="c1">#acc_mat_out=np.divide(acc_mat,count_acc*acc_mat.shape[1])</span>
        <span class="c1">#acc_mat_norm=np.divide(acc_mat,count_acc*acc_mat.shape[1])</span>
        <span class="n">acc_mat_out</span><span class="o">=</span><span class="n">acc_mat_norm</span>
        <span class="n">multiplier_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">acc_mat_norm</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">power_auto</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">acc_mat_norm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">acc_mat_norm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">power_auto</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">acc_mat_norm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">acc_mat_norm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">acc_mat_norm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">multiplier_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">power_auto</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">power_auto</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="n">acc_mat_out</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">acc_mat_norm</span><span class="p">,</span><span class="n">multiplier_mat</span><span class="p">)</span>
        <span class="c1">#acc_mat_out=np.divide(np.multiply(acc_mat_norm,multiplier_mat),count_acc*acc_mat.shape[1])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">acc_mat_out</span><span class="o">=</span><span class="n">acc_mat</span>
    
    <span class="k">return</span><span class="p">(</span><span class="n">acc_mat_out</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_val_for_fringe_exp"><a class="viewcode-back" href="../lib_fx_stack.html#lib_fx_stack.get_val_for_fringe_exp">[docs]</a><span class="k">def</span> <span class="nf">get_val_for_fringe_exp</span><span class="p">(</span><span class="n">sideband</span><span class="p">,</span><span class="n">data_type</span><span class="p">,</span><span class="n">freq_channel</span><span class="p">,</span><span class="n">fs</span><span class="p">,</span><span class="n">r_recalc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute vector &#39;x&#39; with values that will go into e^j(2.pi.x) to be used in fringe rotation.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     sideband : char {&#39;L&#39;,&#39;U&#39;}</span>
<span class="sd">         &#39;L&#39; for LSB, &#39;U&#39; for USB.</span>
<span class="sd">     datatype : char {&#39;c&#39;,&#39;r&#39;}</span>
<span class="sd">         &#39;c&#39; for complex samples, &#39;r&#39; for real samples.</span>
<span class="sd">     freq_channel : float</span>
<span class="sd">         channel frequency [Hz] as in configuration file.</span>
<span class="sd">     fs : float</span>
<span class="sd">         sampling frequency [Hz].</span>
<span class="sd">     r_recalc : 1D np.array of float</span>
<span class="sd">         delay values.</span>
<span class="sd">     </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     val : 1D np.array of float</span>
<span class="sd">         results.</span>
<span class="sd">     </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    |</span>
<span class="sd">    | **Configuration:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Enable USE_NE_FRINGE for using numexpr, and if so, configure THREADS_NE for multithreading.</span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **TO DO:**</span>
<span class="sd">    |</span>
<span class="sd">    |  This should be checked.</span>
<span class="sd">    |  Case USB complex not tested yet.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># TO DO: check this</span>
    <span class="c1">#                                                               # [LSB/USB], [real/complex]</span>
    <span class="k">if</span> <span class="n">sideband</span><span class="o">==</span><span class="s1">&#39;L&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data_type</span><span class="o">==</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="c1">#                                           #   LSB       complex</span>
            <span class="k">if</span> <span class="n">USE_NE_FRINGE</span><span class="p">:</span>
                <span class="n">val</span><span class="o">=</span><span class="n">ne</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s2">&quot;(freq_channel-fs)*r_recalc&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val</span><span class="o">=</span><span class="p">(</span><span class="n">freq_channel</span><span class="o">-</span><span class="n">fs</span><span class="p">)</span><span class="o">*</span><span class="n">r_recalc</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1">#                                                       #   LSB       real    </span>
            <span class="k">if</span> <span class="n">USE_NE_FRINGE</span><span class="p">:</span>
                <span class="c1">#val=ne.evaluate(&quot;(freq_channel-fs/2)*r_recalc&quot;)</span>
                <span class="n">val</span><span class="o">=</span><span class="n">ne</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s2">&quot;freq_channel*r_recalc&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#val=(freq_channel-fs/2)*r_recalc</span>
                <span class="n">val</span><span class="o">=</span><span class="n">freq_channel</span><span class="o">*</span><span class="n">r_recalc</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1">#                                                            #   USB       both</span>
        <span class="k">if</span> <span class="n">USE_NE_FRINGE</span><span class="p">:</span>
            <span class="n">val</span><span class="o">=</span><span class="n">ne</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s2">&quot;freq_channel*r_recalc&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">val</span><span class="o">=</span><span class="n">freq_channel</span><span class="o">*</span><span class="n">r_recalc</span>
    <span class="k">return</span><span class="p">(</span><span class="n">val</span><span class="p">)</span></div>



<div class="viewcode-block" id="fringe_rotation_wrap"><a class="viewcode-back" href="../lib_fx_stack.html#lib_fx_stack.fringe_rotation_wrap">[docs]</a><span class="k">def</span> <span class="nf">fringe_rotation_wrap</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
   <span class="k">return</span><span class="p">(</span><span class="n">fringe_rotation_work</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span></div>


<div class="viewcode-block" id="fringe_rotation_work"><a class="viewcode-back" href="../lib_fx_stack.html#lib_fx_stack.fringe_rotation_work">[docs]</a><span class="k">def</span> <span class="nf">fringe_rotation_work</span><span class="p">(</span><span class="n">clock_diff</span><span class="p">,</span><span class="n">poly_diff</span><span class="p">,</span><span class="n">seconds_ref_clock</span><span class="p">,</span><span class="n">delay_rate_ref</span><span class="p">,</span><span class="n">timescale</span><span class="p">,</span><span class="n">seconds_offset</span><span class="p">,</span><span class="n">n_samples</span><span class="p">,</span><span class="n">sideband</span><span class="p">,</span>\
                             <span class="n">last_n_samples</span><span class="p">,</span><span class="n">str_st</span><span class="p">,</span><span class="n">last_str_st</span><span class="p">,</span><span class="n">data_type</span><span class="p">,</span><span class="n">last_data_type</span><span class="p">,</span><span class="n">first_iteration</span><span class="p">,</span><span class="n">freq_channel</span><span class="p">,</span><span class="n">fs</span><span class="p">,</span><span class="n">F1_i</span><span class="p">,</span>\
                             <span class="n">nr</span><span class="p">,</span><span class="n">rotation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Worker for fringe rotation, see fringe_rotation() for more details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#os.system(&quot;taskset -p 0xff %d&quot; % os.getpid())</span>
    <span class="n">nr</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">[</span><span class="n">r_recalc</span><span class="p">,</span><span class="n">m_unused</span><span class="p">,</span><span class="n">c_unused</span><span class="p">,</span><span class="n">r_unused</span><span class="p">,</span><span class="n">a_unused</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_delay_val</span><span class="p">(</span>\
                               <span class="n">clock_diff</span><span class="o">=</span><span class="n">clock_diff</span><span class="p">,</span>\
                               <span class="n">poly_diff</span><span class="o">=</span><span class="n">poly_diff</span><span class="p">,</span>\
                               <span class="n">seconds_ref_clock</span><span class="o">=</span><span class="n">seconds_ref_clock</span><span class="p">,</span>\
                               <span class="n">seconds_ref_poly</span><span class="o">=</span><span class="n">delay_rate_ref</span><span class="p">,</span>\
                               <span class="n">seconds</span><span class="o">=</span><span class="n">timescale</span><span class="p">,</span>\
                               <span class="n">seconds_offset</span><span class="o">=</span><span class="n">seconds_offset</span><span class="p">,</span>\
                               <span class="n">v</span><span class="o">=</span><span class="n">DEBUG_LIB_DELAY</span><span class="p">,</span>\
                               <span class="n">diff_pol</span><span class="o">=</span><span class="n">DIFF_POLY</span><span class="p">)</span>
    
    <span class="n">first_delay</span><span class="o">=</span><span class="n">r_recalc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">last_delay</span><span class="o">=</span><span class="n">r_recalc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">step_delay</span><span class="o">=</span><span class="p">(</span><span class="n">last_delay</span><span class="o">-</span><span class="n">first_delay</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
    <span class="n">rate_interval</span><span class="o">=</span><span class="n">step_delay</span><span class="o">*</span><span class="n">fs</span>
    <span class="k">if</span> <span class="n">FULL_TIMESCALE</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Linear interpolation</span>
        
        
        <span class="n">base_recalc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">float</span><span class="p">(</span><span class="n">n_samples</span><span class="p">))</span>
        <span class="n">r_recalc</span><span class="o">=</span><span class="n">first_delay</span><span class="o">+</span><span class="n">base_recalc</span><span class="o">*</span><span class="n">step_delay</span>
        <span class="k">if</span> <span class="n">DEBUG_DELAYS</span><span class="p">:</span>
            <span class="n">diff_last_first</span><span class="o">=</span><span class="n">last_delay</span><span class="o">-</span><span class="n">first_delay</span>
            
    <span class="c1">#else:</span>
    <span class="c1">#    rate_interval=0</span>
    
    <span class="c1"># Avoid recomputing if same delay, same number of samples and same type. Streams for the same station</span>
    <span class="c1">#  should be consecutive.</span>
    <span class="n">computed</span><span class="o">=</span><span class="mi">0</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">str_st</span><span class="o">!=</span><span class="n">last_str_st</span> <span class="ow">and</span> <span class="p">(</span> <span class="n">last_data_type</span><span class="o">!=</span><span class="n">data_type</span> <span class="ow">or</span> <span class="n">last_n_samples</span><span class="o">!=</span><span class="n">n_samples</span><span class="p">))</span> <span class="ow">or</span> <span class="n">first_iteration</span><span class="p">:</span>
        <span class="n">computed</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">SAVE_TIME_ROTATIONS</span><span class="p">:</span>
            <span class="n">first_iteration</span><span class="o">=</span><span class="mi">0</span>

        <span class="n">val</span><span class="o">=</span><span class="n">get_val_for_fringe_exp</span><span class="p">(</span><span class="n">sideband</span><span class="p">,</span><span class="n">data_type</span><span class="p">,</span><span class="n">freq_channel</span><span class="p">,</span><span class="n">fs</span><span class="p">,</span><span class="n">r_recalc</span><span class="p">)</span> <span class="c1"># get vector x</span>
        <span class="p">[</span><span class="n">ru</span><span class="p">,</span><span class="n">nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_exp</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>                                                  <span class="c1"># get vector e^j(2.pi.x)</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">nr</span><span class="p">):</span>
            <span class="c1">#rotation=get_rotator([ru])</span>
            <span class="n">rotation</span><span class="o">=</span><span class="n">ru</span>
    
    
    <span class="c1">#last_r_recalc=r_recalc</span>
    <span class="n">last_data_type</span><span class="o">=</span><span class="n">data_type</span>
    <span class="n">last_str_st</span><span class="o">=</span><span class="n">str_st</span>
    

    <span class="k">if</span> <span class="ow">not</span> <span class="n">nr</span><span class="p">:</span>
        <span class="c1">#if USE_NE_FRINGE:</span>
        <span class="c1">#    interm=F1[i]</span>
        <span class="c1">#F1[i]=ne.evaluate(&quot;interm*rotation&quot;) # not faster</span>
        <span class="c1">#else:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">F1_i</span><span class="p">,</span><span class="n">rotation</span><span class="p">,</span><span class="n">F1_i</span><span class="p">)</span>
    <span class="k">return</span><span class="p">([</span><span class="n">F1_i</span><span class="p">,</span><span class="n">rotation</span><span class="p">,</span><span class="n">last_data_type</span><span class="p">,</span><span class="n">last_str_st</span><span class="p">,</span><span class="n">first_iteration</span><span class="p">,</span><span class="n">first_delay</span><span class="p">,</span><span class="n">last_delay</span><span class="p">,</span><span class="n">rate_interval</span><span class="p">,</span><span class="n">computed</span><span class="p">])</span></div>


<div class="viewcode-block" id="fringe_rotation"><a class="viewcode-back" href="../lib_fx_stack.html#lib_fx_stack.fringe_rotation">[docs]</a><span class="k">def</span> <span class="nf">fringe_rotation</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span><span class="n">F_first_sample</span><span class="p">,</span><span class="n">F_rates</span><span class="p">,</span><span class="n">freq_channel</span><span class="p">,</span><span class="n">F_fs</span><span class="p">,</span><span class="n">F_delays</span><span class="p">,</span><span class="n">F_refs</span><span class="p">,</span><span class="n">block_time</span><span class="p">,</span><span class="n">F_frac</span><span class="p">,</span><span class="n">F_adj_shift_partial</span><span class="p">,</span><span class="n">F_side</span><span class="p">,</span><span class="n">F_ind</span><span class="p">,</span><span class="n">F_lti</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fringe rotation correction (previously doppler_correction()).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     F1 : list</span>
<span class="sd">         list with stored samples to be processed, which number of samples is an integer multiple of the fft length.</span>
<span class="sd">     F1_first_sample : list</span>
<span class="sd">         list with first sample (integer) corresponding to the samples in F1.</span>
<span class="sd">     F_rates : list</span>
<span class="sd">         list with the delay information for the latest data received. Note that if follows a different ordering as F1 here,</span>
<span class="sd">                         and thus its elements has to be accessed through F_refs.</span>
<span class="sd">     freq_channel : float</span>
<span class="sd">         sky frequency [Hz].</span>
<span class="sd">     F_fs : list</span>
<span class="sd">         list with the sampling frequency corresponding to the samples in F1 (access through F_refs).</span>
<span class="sd">     F_delays</span>
<span class="sd">         [unused] absolute delays of the streams in F1 (access through F_refs).</span>
<span class="sd">     F_refs : list</span>
<span class="sd">         list of indices for accessing F_rates, F_fs, etc (those filled in update_stored_samples()).</span>
<span class="sd">     block_time</span>
<span class="sd">         time corresponding to this accumulation period (unused).</span>
<span class="sd">     F_frac</span>
<span class="sd">         fractional and integer delay corresponding to F1 (access through F_refs).</span>
<span class="sd">     F_adj_shift_partial</span>
<span class="sd">         [unused] previously, list with information on added/dropped samples based on fractional sample correction</span>
<span class="sd">                        overflows, currently unused.</span>
<span class="sd">     F_side : list</span>
<span class="sd">         list with sideband for each of the streams in F1 (&#39;l&#39; for LSB, &#39;u&#39; for USB) (access through F_refs).</span>
<span class="sd">     F_ind : list</span>
<span class="sd">         list of station identifiers in the format used in the key (e.g. 0.0, 0.1)</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     F1</span>
<span class="sd">         F1 (input) with applied rotations if required.</span>
<span class="sd">     F_first_sample</span>
<span class="sd">         list with updated first samples (added number of samples in each element of F1).</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    |</span>
<span class="sd">    | **Configuration for trade-off performance vs. precision:**</span>
<span class="sd">    |</span>
<span class="sd">    |  There are three main modes, configuration in const_performance.py:</span>
<span class="sd">    |  FULL_TIMESCALE=0 -&gt; Min. precision, Max. performance: only a phase rotation is applied, based on the delay computed for</span>
<span class="sd">    |                                                         the first sample.</span>
<span class="sd">    |  FULL_TIMESCALE=1 (default) -&gt; Max. precision, Min. performance: a frequency shift is applied with a complete rotator, that is,</span>
<span class="sd">    |                                                         delays are computed for all the samples.</span>
<span class="sd">    |  FULL_TIMESCALE=2 -&gt; Trade-off solution: delay is computed for the first and last sample, and a linear interpolation is </span>
<span class="sd">    |                                                         done for obtaining the rest of delays. </span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **Approximations:**</span>
<span class="sd">    |</span>
<span class="sd">    |  For modes FULL_TIMESCALE 1 and 2, the time scale array is computed only once, assuming the same sampling frequency for </span>
<span class="sd">    |    all the streams.</span>
<span class="sd">    | </span>
<span class="sd">    | The processing currently performed in a loop iterating over the streams in F1, that should be sorted. Given this, for each</span>
<span class="sd">    |    stream, it is checked if the previous processed stream corresponded to the same station, and if so, the previous rotators</span>
<span class="sd">    |    are used.</span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **Debugging:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Activate DEBUG_DELAYS for tabulated output of the delay computations.</span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **References:**</span>
<span class="sd">    |</span>
<span class="sd">    |  [Th04] p172-173</span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **TO DO:**</span>
<span class="sd">    |</span>
<span class="sd">    |  F_fs: assuming single sampling frequency</span>
<span class="sd">    |  Bring configuration constants to configuration files.</span>
<span class="sd">    |  Delete unused arguments.</span>
<span class="sd">    | </span>
<span class="sd">    |  Check if necessary to apply fractional offsets.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nr</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">rotation</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="k">if</span> <span class="n">USE_MP</span><span class="p">:</span>
        <span class="n">jobs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">arg_list</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">MP_THREADS</span><span class="p">)</span>
        
    
    <span class="n">F1_out</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">F_first_sample_out</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">first_iteration</span><span class="o">=</span><span class="mi">1</span>
    <span class="c1">#last_r_recalc=0</span>
    <span class="n">last_data_type</span><span class="o">=</span><span class="s1">&#39;x&#39;</span>
    <span class="n">last_n_samples</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">last_str_st</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    
    
    
    <span class="c1"># Assuming same length for all rows</span>
    <span class="n">n_samples</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">F1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">fs</span><span class="o">=</span><span class="n">F_fs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Ts</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">fs</span>
    <span class="k">if</span> <span class="n">FULL_TIMESCALE</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Evaluate delay for all samples</span>
        <span class="c1">#timescale_base_no_offset=np.array(list(range(n_samples)),dtype=float)</span>
        <span class="n">timescale_base_no_offset</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Timescale in seconds</span>
        <span class="n">timescale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">timescale_base_no_offset</span><span class="p">,</span><span class="n">Ts</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">FULL_TIMESCALE</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Interpolate (linear based on first and last sample)</span>
        <span class="n">timescale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="nb">float</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span><span class="o">*</span><span class="n">Ts</span><span class="p">])</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">timescale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
    
    
  
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">F1</span><span class="p">)):</span>
        <span class="n">str_st</span><span class="o">=</span><span class="n">F_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">first_sample</span><span class="o">=</span><span class="n">F_first_sample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="n">last_sample</span><span class="o">=</span><span class="n">first_sample</span><span class="o">+</span><span class="n">n_samples</span>
        
        <span class="c1"># Delay polynomials for this station</span>
        <span class="p">[</span><span class="n">delay_rate_0</span><span class="p">,</span><span class="n">delay_rate_1</span><span class="p">,</span><span class="n">delay_rate_2</span><span class="p">,</span><span class="n">delay_rate_ref</span><span class="p">,</span><span class="n">clock_rate_0</span><span class="p">,</span><span class="n">clock_rate_1</span><span class="p">,</span><span class="n">clock_abs_rate_0</span><span class="p">,</span>\
                                <span class="n">clock_abs_rate_1</span><span class="p">,</span><span class="n">clock_rate_ref</span><span class="p">,</span><span class="n">model_only_delay</span><span class="p">,</span><span class="n">clock_only_delay</span><span class="p">,</span><span class="n">diff_frac</span><span class="p">]</span><span class="o">=</span><span class="n">F_rates</span><span class="p">[</span><span class="n">F_refs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="p">[</span><span class="n">fractional_sample_correction</span><span class="p">,</span><span class="n">shift_delay</span><span class="p">]</span><span class="o">=</span><span class="n">F_frac</span><span class="p">[</span><span class="n">F_refs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        
        <span class="n">fs</span><span class="o">=</span><span class="n">F_fs</span><span class="p">[</span><span class="n">F_refs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">Ts</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">fs</span>
        <span class="p">[</span><span class="n">sideband</span><span class="p">,</span><span class="n">data_type</span><span class="p">]</span><span class="o">=</span><span class="n">F_side</span><span class="p">[</span><span class="n">F_refs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        
        <span class="c1"># Integer delay already applied (multiple of Ts)</span>
        <span class="n">shift_delay</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">error_f_frac</span><span class="o">=</span><span class="mi">0</span>
        
        <span class="c1"># Delays at each sample</span>
        <span class="n">first_sample_s</span><span class="o">=</span><span class="n">first_sample</span><span class="o">*</span><span class="n">Ts</span>
 
        <span class="n">seconds_offset</span> <span class="o">=</span> <span class="n">first_sample_s</span>
        
        <span class="n">clock_diff</span> <span class="o">=</span> <span class="p">[</span><span class="n">clock_rate_0</span><span class="p">,</span><span class="n">clock_rate_1</span><span class="p">]</span>
        <span class="n">poly_diff</span> <span class="o">=</span> <span class="p">[</span><span class="n">delay_rate_0</span><span class="p">,</span><span class="n">delay_rate_1</span><span class="p">,</span><span class="n">delay_rate_2</span><span class="p">]</span>
        <span class="n">clock_abs</span> <span class="o">=</span> <span class="p">[</span><span class="n">clock_abs_rate_0</span><span class="p">,</span><span class="n">clock_abs_rate_1</span><span class="p">]</span>
        <span class="n">seconds_ref_clock</span><span class="o">=</span><span class="n">clock_rate_ref</span>
        
        <span class="c1"># clock_diff,poly_diff,seconds_ref_clock,delay_rate_ref,timescale,seconds_offset,</span>
        <span class="c1">#   DEBUG_LIB_DELAY,DIFF_POLY,FULL_TIMESCALE</span>
        <span class="c1"># n_samples,last_n_samples,str_st,last_str_st,data_type,last_data_type,first_iteration,freq_channel,fs,F1[i]</span>
        
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">USE_MP</span><span class="p">:</span>
            <span class="c1"># Serial execution</span>
            <span class="p">[</span><span class="n">F1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">rotation</span><span class="p">,</span><span class="n">last_data_type</span><span class="p">,</span><span class="n">last_str_st</span><span class="p">,</span><span class="n">first_iteration</span><span class="p">,</span><span class="n">first_delay</span><span class="p">,</span><span class="n">last_delay</span><span class="p">,</span>\
                             <span class="n">rate_interval</span><span class="p">,</span><span class="n">computed</span><span class="p">]</span> <span class="o">=</span> <span class="n">fringe_rotation_work</span><span class="p">(</span><span class="n">clock_diff</span><span class="p">,</span><span class="n">poly_diff</span><span class="p">,</span>\
                                 <span class="n">seconds_ref_clock</span><span class="p">,</span><span class="n">delay_rate_ref</span><span class="p">,</span><span class="n">timescale</span><span class="p">,</span><span class="n">seconds_offset</span><span class="p">,</span><span class="n">n_samples</span><span class="p">,</span><span class="n">sideband</span><span class="p">,</span>\
                                 <span class="n">last_n_samples</span><span class="p">,</span><span class="n">str_st</span><span class="p">,</span><span class="n">last_str_st</span><span class="p">,</span><span class="n">data_type</span><span class="p">,</span><span class="n">last_data_type</span><span class="p">,</span><span class="n">first_iteration</span><span class="p">,</span>\
                                 <span class="n">freq_channel</span><span class="p">,</span><span class="n">fs</span><span class="p">,</span><span class="n">F1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">nr</span><span class="p">,</span><span class="n">rotation</span><span class="p">)</span>
            <span class="c1">#if SAVE_TIME_ROTATIONS:</span>
            <span class="c1">#    first_iteration=0</span>

        
            <span class="k">if</span> <span class="n">DEBUG_DELAYS</span><span class="p">:</span>
                <span class="n">print_debug_r_delays_d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">F_refs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">F_ind</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">first_sample</span><span class="p">,</span><span class="n">n_samples</span><span class="p">,</span><span class="n">timescale</span><span class="p">,</span><span class="n">timescale</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">timescale</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>\
                                         <span class="n">seconds_offset</span><span class="p">,</span><span class="n">first_delay</span><span class="p">,</span><span class="n">last_delay</span><span class="p">,</span><span class="n">rate_interval</span><span class="p">,</span><span class="n">fractional_sample_correction</span><span class="p">,</span>\
                                         <span class="n">diff_frac</span><span class="p">,</span><span class="n">computed</span><span class="p">,</span><span class="n">nr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Parallel</span>
            <span class="n">arg_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">clock_diff</span><span class="p">,</span><span class="n">poly_diff</span><span class="p">,</span><span class="n">seconds_ref_clock</span><span class="p">,</span><span class="n">delay_rate_ref</span><span class="p">,</span><span class="n">timescale</span><span class="p">,</span><span class="n">seconds_offset</span><span class="p">,</span>\
                             <span class="n">n_samples</span><span class="p">,</span><span class="n">sideband</span><span class="p">,</span><span class="n">last_n_samples</span><span class="p">,</span><span class="n">str_st</span><span class="p">,</span><span class="n">last_str_st</span><span class="p">,</span><span class="n">data_type</span><span class="p">,</span><span class="n">last_data_type</span><span class="p">,</span>\
                             <span class="n">first_iteration</span><span class="p">,</span><span class="n">freq_channel</span><span class="p">,</span><span class="n">fs</span><span class="p">,</span><span class="n">F1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">nr</span><span class="p">,</span><span class="n">rotation</span><span class="p">])</span>
    
    
    <span class="k">if</span> <span class="n">USE_MP</span><span class="p">:</span> 
        <span class="n">F1_and_rotations</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">fringe_rotation_wrap</span><span class="p">,</span><span class="n">arg_list</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">F1</span><span class="o">=</span><span class="p">[</span><span class="n">F1_and_rot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">F1_and_rot</span> <span class="ow">in</span> <span class="n">F1_and_rotations</span><span class="p">]</span>
 
     
    <span class="k">return</span><span class="p">([</span><span class="n">F1</span><span class="p">,</span><span class="n">F_first_sample</span><span class="p">])</span></div>


<div class="viewcode-block" id="compute_f_all"><a class="viewcode-back" href="../lib_fx_stack.html#lib_fx_stack.compute_f_all">[docs]</a><span class="k">def</span> <span class="nf">compute_f_all</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span><span class="n">fft_size</span><span class="p">,</span><span class="n">windowing</span><span class="p">,</span><span class="n">dtype_complex</span><span class="p">,</span><span class="n">F_frac</span><span class="o">=</span><span class="p">[],</span><span class="n">F_fs</span><span class="o">=</span><span class="p">[],</span><span class="n">F_refs</span><span class="o">=</span><span class="p">[],</span><span class="n">freq_channel</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>\
                      <span class="n">F_first_sample</span><span class="o">=</span><span class="p">[],</span><span class="n">F_rates</span><span class="o">=</span><span class="p">[],</span><span class="n">F_pcal_fix</span><span class="o">=</span><span class="p">[],</span><span class="n">F_side</span><span class="o">=</span><span class="p">[],</span><span class="n">F_ind</span><span class="o">=</span><span class="p">[],</span><span class="n">F_lti</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute FFTs for all stations (all-baselines-per-task mode), and correct for fractional sample correction (linear phase).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     F1</span>
<span class="sd">         list of stored samples (corresponding actually to F1_partial). Each element of the list is a numpy array</span>
<span class="sd">               with the complex samples in the time domain, with a number of samples that is a multiply of the FFT length.</span>
<span class="sd">     fft_size : int</span>
<span class="sd">         number of coefficients in the FFT.</span>
<span class="sd">     windowing : str</span>
<span class="sd">         shape of the window before FFT, currently &#39;square&#39; by default.</span>
<span class="sd">     dtype_complex: type of data for initialization of the rotators.</span>
<span class="sd">     F_frac</span>
<span class="sd">         fractional and integer offsets applied at the mapper (acces via F_refs).</span>
<span class="sd">     F_fs</span>
<span class="sd">         sampling frequency for each stream in F1.</span>
<span class="sd">     F_refs</span>
<span class="sd">         indices to acces F_frac etc based on F_ind, i.e. from stored to new.</span>
<span class="sd">     freq_channel</span>
<span class="sd">         sky frequency.</span>
<span class="sd">     F_first_sample</span>
<span class="sd">         first sample number (actually last sample number plus one, it has to be corrected by subtracting the number of samples in F1.</span>
<span class="sd">     F_rates</span>
<span class="sd">         delay information for each of the streams (access via F_refs).</span>
<span class="sd">     F_pcal_fix</span>
<span class="sd">         offset for pcal accumulation results (due to the initial offset applied in the mapper). Later the pcal</span>
<span class="sd">              signals will be realigned as if no delay was applied to them.</span>
<span class="sd">     F_side</span>
<span class="sd">         list of single side band side for each stream, &#39;l&#39; LSB or &#39;u&#39; USB (access via F_refs).</span>
<span class="sd">     F_ind</span>
<span class="sd">         list of station-polarization identifiers corresponding to the streams in F1 (this actually corresponds</span>
<span class="sd">               to F1_ind_partial.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     F1_fft</span>
<span class="sd">         list of array of arrays with FFTs with rotations applied.</span>
<span class="sd">     None</span>
<span class="sd">         [unused] previously outputing the conjugate of F1_fft, removed for efficiency.</span>
<span class="sd">     F_adj_shift_partial_out</span>
<span class="sd">         [unused] previously used to keep track of the number of samples to </span>
<span class="sd">                    add/drop due to fractional sample overflows, superseded for F_frac_over.</span>
<span class="sd">     F_adj_shift_pcal_out</span>
<span class="sd">         [unused] previously used to keep track of the number of samples to </span>
<span class="sd">                    roll the phase calibration results prior to FFT them, superseded for F_pcal_fix_out.</span>
<span class="sd">     F_pcal_fix_out</span>
<span class="sd">         list with number of samples to roll the pcal streams prior to FFT them.</span>
<span class="sd">     F_first_sample_out</span>
<span class="sd">         first sample for each stream (actually last sample number plus one).</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    |</span>
<span class="sd">    | **Procedure:**</span>
<span class="sd">    |</span>
<span class="sd">    |  For each element in F1:</span>
<span class="sd">    |   1. Create an array of arrays with the FFTs of the samples grouped into arrays of fft_size samples.</span>
<span class="sd">    |   2. Create a frequency scale of fft_size (linear from 0 to (n-1)/n).</span>
<span class="sd">    |   3a. If the computations have already been done for the same station, take the results.</span>
<span class="sd">    |   3b. Otherwise:</span>
<span class="sd">    |       Compute delay for the first sample, then fractional part of this delay, then scale frequency scale, then exponential.</span>
<span class="sd">    |       Rotate the FFT using the previous rotator.</span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **References:**</span>
<span class="sd">    |</span>
<span class="sd">    |  [Th04] p363</span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **TO DO:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Detail where in the FFT the fractional sample for the rotator is evaluated.</span>
<span class="sd">    |    </span>
<span class="sd">    |  Check correction to phase in p363.   </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">F_adj_shift_partial_out</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">F_adj_shift_partial_mon</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">F_adj_shift_pcal_out</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">F_pcal_fix_out</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">F_first_sample_out</span><span class="o">=</span><span class="p">[]</span>
    <span class="c1"># TO DO: assuming all data same type for now</span>
    <span class="p">[</span><span class="n">sideband</span><span class="p">,</span><span class="n">data_type</span><span class="p">]</span><span class="o">=</span><span class="n">F_side</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
    <span class="c1"># Windowing and FFT</span>
    <span class="n">first_iteration</span><span class="o">=</span><span class="mi">1</span>
    <span class="n">last_fractional_recalc</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">last_str_st</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="n">F1_fft</span> <span class="o">=</span> <span class="n">window_and_fft</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span><span class="n">fft_size</span><span class="p">,</span><span class="n">windowing</span><span class="p">,</span><span class="n">flatten_chunks</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">dtype_complex</span><span class="o">=</span><span class="n">dtype_complex</span><span class="p">)</span> <span class="c1"># ,rfft_data_type=data_type)</span>
    
    <span class="c1"># If real samples take only half FFT (LSB or USB as applicable)</span>
    <span class="k">if</span> <span class="n">data_type</span><span class="o">==</span><span class="s1">&#39;r&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sideband</span><span class="o">==</span><span class="s1">&#39;L&#39;</span><span class="p">:</span>
            <span class="n">F1_fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">F1_fft</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:</span><span class="n">fft_size</span><span class="o">//</span><span class="mi">2</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">F1_fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">F1_fft</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">fft_size</span><span class="o">//</span><span class="mi">2</span><span class="p">:],</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">shift_int</span><span class="o">=</span><span class="mi">0</span>
    <span class="c1"># Fractional sample correction</span>
    <span class="n">F1_fft_rot</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">F1_fft</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype_complex</span><span class="p">)</span>
    <span class="n">error_f_frac</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">F_rates</span><span class="o">!=</span><span class="p">[]:</span>
        
        <span class="k">if</span> <span class="n">data_type</span><span class="o">==</span><span class="s1">&#39;c&#39;</span><span class="p">:</span>
            <span class="n">freqscale2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">fft_size</span><span class="p">))</span>
            <span class="n">fft_size_comp</span><span class="o">=</span><span class="n">fft_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sideband</span><span class="o">==</span><span class="s1">&#39;L&#39;</span><span class="p">:</span>
                <span class="n">freqscale2</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">fft_size</span><span class="p">))</span> <span class="c1"># First half of the full vector (e.g. [-0.5 -0.375 -0.25 -0.125] with fft_size=8)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">freqscale2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">fft_size</span><span class="p">))[:</span><span class="n">fft_size</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># Second half the full vector (e.g. [ 0. 0.125 0.25 0.375] with fft_size=8)</span>

            <span class="n">fft_size_comp</span><span class="o">=</span><span class="n">fft_size</span><span class="o">//</span><span class="mi">2</span>
        
        <span class="c1"># p363</span>

        <span class="k">for</span> <span class="n">stpol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">F1_fft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">fs</span><span class="o">=</span><span class="n">F_fs</span><span class="p">[</span><span class="n">F_refs</span><span class="p">[</span><span class="n">stpol</span><span class="p">]]</span>
            <span class="n">Ts</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">fs</span>
            <span class="p">[</span><span class="n">sideband</span><span class="p">,</span><span class="n">data_type</span><span class="p">]</span><span class="o">=</span><span class="n">F_side</span><span class="p">[</span><span class="n">F_refs</span><span class="p">[</span><span class="n">stpol</span><span class="p">]]</span>
            <span class="c1">#str_st=F_ind[F_refs[stpol]].split(&#39;.&#39;)[0]</span>
            <span class="n">str_st</span><span class="o">=</span><span class="n">F_ind</span><span class="p">[</span><span class="n">stpol</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                            
            <span class="c1">#sample0=F_first_sample[F_refs[stpol]]-len(F1[F_refs[stpol]])</span>
            
            <span class="n">sample0</span><span class="o">=</span><span class="n">F_first_sample</span><span class="p">[</span><span class="n">F_refs</span><span class="p">[</span><span class="n">stpol</span><span class="p">]]</span>
            <span class="c1">##adjustments (padding) from hstack_samples...</span>
            <span class="c1">#sample0+=F_lti[stpol][3]</span>
            
            <span class="n">num_samples</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">F1</span><span class="p">[</span><span class="n">F_refs</span><span class="p">[</span><span class="n">stpol</span><span class="p">]])</span>
            <span class="n">F_first_sample_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample0</span><span class="o">+</span><span class="n">num_samples</span><span class="p">)</span>
            <span class="n">computed</span><span class="o">=</span><span class="mi">0</span>
            <span class="n">error_f_frac</span><span class="o">=</span><span class="mi">0</span>
           
            <span class="n">i_row</span><span class="o">=-</span><span class="mi">1</span>
            
            <span class="k">if</span> <span class="n">last_str_st</span><span class="o">!=</span><span class="n">str_st</span> <span class="ow">or</span> <span class="n">first_iteration</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">SAVE_TIME_ROTATIONS</span><span class="p">:</span>
                    <span class="n">first_iteration</span><span class="o">=</span><span class="mi">0</span>

                <span class="n">first_sample</span><span class="o">=</span><span class="n">sample0</span>
                <span class="n">first_sample_s</span><span class="o">=</span><span class="n">first_sample</span><span class="o">*</span><span class="n">Ts</span>
                
                
                <span class="p">[</span><span class="n">delay_rate_0</span><span class="p">,</span><span class="n">delay_rate_1</span><span class="p">,</span><span class="n">delay_rate_2</span><span class="p">,</span><span class="n">delay_rate_ref</span><span class="p">,</span><span class="n">clock_rate_0</span><span class="p">,</span>\
                       <span class="n">clock_rate_1</span><span class="p">,</span><span class="n">clock_abs_rate_0</span><span class="p">,</span><span class="n">clock_abs_rate_1</span><span class="p">,</span><span class="n">clock_rate_ref</span><span class="p">,</span>\
                       <span class="n">model_only_delay</span><span class="p">,</span><span class="n">clock_only_delay</span><span class="p">,</span><span class="n">diff_frac</span><span class="p">]</span><span class="o">=</span><span class="n">F_rates</span><span class="p">[</span><span class="n">F_refs</span><span class="p">[</span><span class="n">stpol</span><span class="p">]]</span>
                <span class="n">diff_frac</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">[</span><span class="n">fractional_sample_correction</span><span class="p">,</span><span class="n">shift_delay</span><span class="p">]</span><span class="o">=</span><span class="n">F_frac</span><span class="p">[</span><span class="n">F_refs</span><span class="p">[</span><span class="n">stpol</span><span class="p">]]</span>
                <span class="n">shift_s</span><span class="o">=</span><span class="n">shift_delay</span><span class="o">*</span><span class="n">fs</span>
                

                <span class="n">frtot_v</span><span class="o">=</span><span class="p">[]</span>
                
                <span class="n">first_iteration_recalc</span><span class="o">=</span><span class="mi">1</span>

                <span class="c1"># TO DO: consider centering in the interval (N//2)</span>
                <span class="n">timescale</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">clock_diff</span> <span class="o">=</span> <span class="p">[</span><span class="n">clock_rate_0</span><span class="p">,</span><span class="n">clock_rate_1</span><span class="p">]</span>
                <span class="n">poly_diff</span> <span class="o">=</span> <span class="p">[</span><span class="n">delay_rate_0</span><span class="p">,</span><span class="n">delay_rate_1</span><span class="p">,</span><span class="n">delay_rate_2</span><span class="p">]</span>
                <span class="n">clock_abs</span> <span class="o">=</span> <span class="p">[</span><span class="n">clock_abs_rate_0</span><span class="p">,</span><span class="n">clock_abs_rate_1</span><span class="p">]</span>          
                <span class="n">seconds_ref_clock</span> <span class="o">=</span> <span class="n">clock_rate_ref</span>
                
                <span class="c1">#if USE_NE_F:</span>
                <span class="c1">#    npr1 = np.arange(F1_fft.shape[1])</span>
                <span class="c1">#    total_timescale = ne.evaluate(&quot;Ts*(sample0+fft_size*npr1)&quot;) # slower</span>
                <span class="c1">#else:</span>
                <span class="n">total_timescale</span> <span class="o">=</span><span class="n">Ts</span><span class="o">*</span><span class="p">(</span><span class="n">sample0</span><span class="o">+</span><span class="n">fft_size</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">F1_fft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                
                <span class="n">total_seconds_offset</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">[</span><span class="n">r_recalc</span><span class="p">,</span><span class="n">m_unused</span><span class="p">,</span><span class="n">c_recalc</span><span class="p">,</span><span class="n">r_unused</span><span class="p">,</span><span class="n">a_unused</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_delay_val</span><span class="p">(</span>\
                                   <span class="n">clock_diff</span><span class="o">=</span><span class="n">clock_diff</span><span class="p">,</span>\
                                   <span class="n">poly_diff</span><span class="o">=</span><span class="n">poly_diff</span><span class="p">,</span>\
                                   <span class="n">seconds_ref_clock</span><span class="o">=</span><span class="n">seconds_ref_clock</span><span class="p">,</span>\
                                   <span class="n">seconds_ref_poly</span><span class="o">=</span><span class="n">delay_rate_ref</span><span class="p">,</span>\
                                   <span class="n">seconds</span><span class="o">=</span><span class="n">total_timescale</span><span class="p">,</span>\
                                   <span class="n">seconds_offset</span><span class="o">=</span><span class="n">total_seconds_offset</span><span class="p">,</span>\
                                   <span class="n">v</span><span class="o">=</span><span class="n">DEBUG_LIB_DELAY</span><span class="p">,</span><span class="n">diff_pol</span><span class="o">=</span><span class="n">DIFF_POLY</span><span class="p">)</span>

                <span class="p">[</span><span class="n">full_fractional_recalc</span><span class="p">,</span><span class="n">fractional_recalc</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_full_frac_val</span><span class="p">(</span><span class="n">r_recalc</span><span class="p">,</span><span class="n">fs</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">F1_fft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                
                    <span class="n">i_row</span><span class="o">+=</span><span class="mi">1</span>
                    <span class="n">fsr</span><span class="o">=</span><span class="n">sample0</span><span class="o">+</span><span class="n">i_row</span><span class="o">*</span><span class="n">fft_size</span>
                    <span class="n">lsr</span><span class="o">=</span><span class="n">fsr</span><span class="o">+</span><span class="n">fft_size</span>

                    
                    <span class="k">if</span> <span class="n">DEBUG_DELAYS</span><span class="p">:</span>
                        <span class="n">print_debug_r_delays_f</span><span class="p">(</span><span class="n">stpol</span><span class="p">,</span><span class="n">F_refs</span><span class="p">[</span><span class="n">stpol</span><span class="p">],</span><span class="n">F_ind</span><span class="p">[</span><span class="n">stpol</span><span class="p">],</span><span class="n">fsr</span><span class="p">,</span><span class="n">num_samples</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">timescale</span><span class="p">),</span>\
                                     <span class="n">total_timescale</span><span class="p">[</span><span class="n">row</span><span class="p">],</span><span class="mf">0.0</span><span class="p">,</span>\
                                     <span class="n">total_seconds_offset</span><span class="p">,</span><span class="n">r_recalc</span><span class="p">[</span><span class="n">row</span><span class="p">],</span><span class="n">r_unused</span><span class="p">,</span><span class="n">a_unused</span><span class="p">,</span><span class="n">fractional_sample_correction</span><span class="p">,</span>\
                                     <span class="n">full_fractional_recalc</span><span class="p">[</span><span class="n">row</span><span class="p">],</span><span class="n">fractional_recalc</span><span class="p">[</span><span class="n">row</span><span class="p">],</span><span class="n">diff_frac</span><span class="p">)</span>
                        
                    
                    <span class="n">computed</span><span class="o">=</span><span class="mi">0</span>
                    <span class="k">if</span> <span class="n">last_fractional_recalc</span><span class="o">!=</span><span class="n">fractional_recalc</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="ow">or</span> <span class="n">first_iteration_recalc</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">SAVE_TIME_ROTATIONS</span><span class="p">:</span>
                            <span class="n">first_iteration_recalc</span><span class="o">=</span><span class="mi">0</span>
                        <span class="n">computed</span><span class="o">=</span><span class="mi">1</span>

                        <span class="c1">#print(str_st)</span>
                        <span class="c1">#print(freqscale2*(fractional_recalc[row]))</span>

                        <span class="p">[</span><span class="n">fr6</span><span class="p">,</span><span class="n">nr</span><span class="p">]</span><span class="o">=</span><span class="n">get_exp</span><span class="p">(</span><span class="n">freqscale2</span><span class="o">*</span><span class="p">(</span><span class="n">fractional_recalc</span><span class="p">[</span><span class="n">row</span><span class="p">]))</span>
                        
                        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">nr</span><span class="p">):</span>
                            <span class="c1">#frtot=get_rotator([fr6])</span>
                            <span class="n">frtot</span><span class="o">=</span><span class="n">fr6</span>
                            <span class="n">frtot_v</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">frtot</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">frtot_v</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mf">1.0</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Skipping, copy last value</span>
                        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">nr</span><span class="p">):</span>
                            <span class="n">frtot_v</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">frtot</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">frtot_v</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mf">1.0</span><span class="p">])</span>

                    <span class="n">last_fractional_recalc</span><span class="o">=</span><span class="n">fractional_recalc</span><span class="p">[</span><span class="n">row</span><span class="p">]</span>
                
            <span class="n">last_str_st</span><span class="o">=</span><span class="n">str_st</span>   
            

            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">F1_fft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">nr</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">F1_fft</span><span class="p">[</span><span class="n">stpol</span><span class="p">,</span><span class="n">row</span><span class="p">,:],</span><span class="n">frtot_v</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">F1_fft</span><span class="p">[</span><span class="n">stpol</span><span class="p">,</span><span class="n">row</span><span class="p">,:])</span>
                    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in rotation: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">frtot_v</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;, &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">F1_fft</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">DEBUG_DELAYS</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zR&quot;</span><span class="o">+</span><span class="n">KEY_SEP</span><span class="o">+</span><span class="s2">&quot;f  &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">stpol</span><span class="p">)</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">F_refs</span><span class="p">[</span><span class="n">stpol</span><span class="p">])</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span><span class="n">F_ind</span><span class="p">[</span><span class="n">stpol</span><span class="p">]</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span>\
                              <span class="nb">str</span><span class="p">(</span><span class="n">fsr</span><span class="p">)</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span>\
                              <span class="s2">&quot; C,R &gt;&gt;&gt;&gt;&quot;</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">191</span><span class="p">)</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">computed</span><span class="p">)</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="ow">not</span><span class="p">(</span><span class="n">nr</span><span class="p">)))</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">error_f_frac</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">DEBUG_FRAC_OVER</span><span class="p">:</span>
                    <span class="c1"># TO DO: create functions in lib_debug(?)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zR&quot;</span><span class="o">+</span><span class="n">KEY_SEP</span><span class="o">+</span><span class="s2">&quot;o&quot;</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">stpol</span><span class="p">)</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">F_refs</span><span class="p">[</span><span class="n">stpol</span><span class="p">])</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span><span class="n">F_ind</span><span class="p">[</span><span class="n">stpol</span><span class="p">]</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span>\
                          <span class="nb">str</span><span class="p">(</span><span class="n">fsr</span><span class="p">)</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">timescale</span><span class="p">))</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">+</span>\
                          <span class="nb">str</span><span class="p">(</span><span class="n">timescale</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">r_recalc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="o">+</span>\
                          <span class="nb">str</span><span class="p">(</span><span class="n">full_fractional_recalc</span><span class="p">[</span><span class="n">row</span><span class="p">])</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="o">+</span>\
                          <span class="nb">str</span><span class="p">(</span><span class="n">fractional_recalc</span><span class="p">[</span><span class="n">row</span><span class="p">])</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="o">+</span>\
                          <span class="c1">#str(frac_re).rjust(10)+\</span>
                          <span class="c1">#str(total_frac_delay_int).rjust(10)+\</span>
                          <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">+</span>\
                          <span class="c1">#str(clock_frac_delay_diff).rjust(20)+\</span>
                          <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="o">+</span>\
                          <span class="c1">#str(clock_frac_delay_int).rjust(10))</span>
                          <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">DEBUG_FRAC_OVER</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zR&quot;</span><span class="o">+</span><span class="n">KEY_SEP</span><span class="o">+</span><span class="s2">&quot;o  &quot;</span><span class="o">+</span><span class="s2">&quot;error&quot;</span><span class="p">)</span>

            <span class="c1"># Correction for pcal</span>
            <span class="n">F_pcal_fix_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shift_delay</span><span class="p">)</span>  
            
         
            
    <span class="k">else</span><span class="p">:</span>
        
        <span class="n">F_first_sample_out</span><span class="o">=</span><span class="n">F_first_sample</span>
        <span class="c1">#for stpol in range(F1_fft.shape[0]):</span>
        <span class="c1">#    for row in range(F1_fft.shape[1]):</span>
        <span class="c1">#        F1_fft_rot[stpol,row,:]=F1_fft[F_refs[stpol],row,:]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zR</span><span class="se">\t</span><span class="s2">Warning: no rotation: first sample &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">F_first_sample</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">F_pcal_fix</span><span class="p">)</span><span class="o">&gt;=</span><span class="nb">len</span><span class="p">(</span><span class="n">F_pcal_fix_out</span><span class="p">))</span><span class="ow">or</span><span class="p">(</span><span class="n">error_f_frac</span><span class="o">==</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">F_pcal_fix_out</span><span class="o">=</span><span class="n">F_pcal_fix</span> <span class="c1">#[:]</span>
    

    <span class="c1">#F2_fft_rot = np.conj(F1_fft_rot)</span>
    <span class="k">if</span> <span class="n">DEBUG_DELAYS</span> <span class="ow">or</span> <span class="n">DEBUG_LIB_DELAY</span><span class="p">:</span> <span class="c1">#or DEBUG_FRAC_OVER :</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zR&quot;</span><span class="o">+</span><span class="n">KEY_SEP</span><span class="o">+</span><span class="s2">&quot;oj&quot;</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">F_adj_shift_partial_out</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;  &quot;</span><span class="o">+</span>\
              <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="n">F_adj_shift_partial_out</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;  &quot;</span><span class="o">+</span>\
              <span class="s2">&quot;   mon &quot;</span><span class="o">+</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="n">F_adj_shift_partial_mon</span><span class="p">)))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zR&quot;</span><span class="o">+</span><span class="n">KEY_SEP</span><span class="o">+</span><span class="s2">&quot;---------------&quot;</span><span class="p">)</span>
        
    <span class="k">return</span><span class="p">([</span><span class="n">F1_fft</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="n">F_adj_shift_partial_out</span><span class="p">,</span><span class="n">F_adj_shift_pcal_out</span><span class="p">,</span><span class="n">F_pcal_fix_out</span><span class="p">,</span><span class="n">F_first_sample_out</span><span class="p">])</span></div>



<div class="viewcode-block" id="compute_x_all"><a class="viewcode-back" href="../lib_fx_stack.html#lib_fx_stack.compute_x_all">[docs]</a><span class="k">def</span> <span class="nf">compute_x_all</span><span class="p">(</span><span class="n">F1_fft</span><span class="p">,</span><span class="n">F2_fft</span><span class="p">,</span><span class="n">count_acc</span><span class="p">,</span><span class="n">acc_mat</span><span class="p">,</span><span class="n">index_scaling_pair</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">dtype_complex</span><span class="o">=</span><span class="nb">complex</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute multiply-accumulate for all baselines (all-baselines-per-task-mode)</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     F1_fft : list of np arrays of arrays </span>
<span class="sd">         FFTs (left term). </span>
<span class="sd">     F2_fft : list of np arrays of arrays with</span>
<span class="sd">         FFTs (right term)If None, then it will take the conjugate of F1_fft.</span>
<span class="sd">     count_acc</span>
<span class="sd">         number of accumulations performed previously during this integration period.</span>
<span class="sd">     acc_mat</span>
<span class="sd">         accumulation matrix with results accumulated during this integration period.</span>
<span class="sd">     index_scaling_pair</span>
<span class="sd">         -1 for all-baselines-per-task mode, positive integer for other modes.</span>
<span class="sd">     dtype_complex</span>
<span class="sd">         type to initialize accumulation matrix.</span>
<span class="sd">     </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     acc_mat</span>
<span class="sd">         accumulation matrix with the new results accumulated (3D numpy array with one row (and one column)</span>
<span class="sd">                      per station-polarization, and fft_size layers/pages with the results of the accumulation </span>
<span class="sd">                       for each pair). Note that the first two dimensions of the matrix are upper triangular, </span>
<span class="sd">                       with the auto-correlations in the main diagonal.</span>
<span class="sd">     count_acc</span>
<span class="sd">         total number of accumulation performed including those in this call.</span>
<span class="sd">     count_sub_acc</span>
<span class="sd">         number of accumulation performed only in this call.</span>
<span class="sd">     n_sp</span>
<span class="sd">         number of station-polarizations (that is also the number of rows/columns of the matrix.</span>
<span class="sd">     </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    |</span>
<span class="sd">    | **TO DO:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Add counters for invalid data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fft_size_comp</span><span class="o">=</span><span class="n">F1_fft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">F2_fft</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">F2_fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">F1_fft</span><span class="p">)</span>
    <span class="n">n_sp</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">F1_fft</span><span class="p">)</span>
    <span class="n">count_acc</span><span class="o">+=</span><span class="nb">len</span><span class="p">(</span><span class="n">F1_fft</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  
    <span class="n">count_sub_acc</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">F1_fft</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">index_scaling_pair</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
        <span class="c1">#All baselines per task</span>
        <span class="k">if</span> <span class="n">acc_mat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">acc_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_sp</span><span class="p">,</span><span class="n">n_sp</span><span class="p">,</span><span class="n">fft_size_comp</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype_complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sp</span><span class="p">):</span>
            <span class="n">acc_mat</span><span class="p">[</span><span class="n">i1</span><span class="p">,</span><span class="n">i1</span><span class="p">:]</span><span class="o">+=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">F1_fft</span><span class="p">[</span><span class="n">i1</span><span class="p">,:],</span><span class="n">F2_fft</span><span class="p">[</span><span class="n">i1</span><span class="p">:,:]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Linear-scaling-stations</span>
        <span class="k">if</span> <span class="n">acc_mat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">acc_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_sp</span><span class="p">,</span><span class="n">fft_size_comp</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype_complex</span><span class="p">)</span>
        <span class="n">acc_mat</span><span class="o">+=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">F1_fft</span><span class="p">[</span><span class="n">index_scaling_pair</span><span class="p">,:],</span><span class="n">F2_fft</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">return</span><span class="p">([</span><span class="n">acc_mat</span><span class="p">,</span><span class="n">count_acc</span><span class="p">,</span><span class="n">count_sub_acc</span><span class="p">,</span><span class="n">n_sp</span><span class="p">])</span></div>





<div class="viewcode-block" id="shortest_row_F"><a class="viewcode-back" href="../lib_fx_stack.html#lib_fx_stack.shortest_row_F">[docs]</a><span class="k">def</span> <span class="nf">shortest_row_F</span><span class="p">(</span><span class="n">F1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the minimum and maximum length of the elements of F1.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     F1 : list of numpy 1D arrays.</span>
<span class="sd">     </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     shortest_row</span>
<span class="sd">         length of the shortest element in F1.</span>
<span class="sd">     longest_row</span>
<span class="sd">         length of the longest element in F1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shortest_row</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">longest_row</span><span class="o">=-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">F1</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">shortest_row</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span><span class="ow">or</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">F1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">&lt;</span><span class="n">shortest_row</span><span class="p">):</span>
            <span class="n">shortest_row</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">F1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">shortest_row</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span><span class="ow">or</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">F1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">&gt;</span><span class="n">longest_row</span><span class="p">):</span>
            <span class="n">longest_row</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">F1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span><span class="p">([</span><span class="n">shortest_row</span><span class="p">,</span><span class="n">longest_row</span><span class="p">])</span></div>


       

<div class="viewcode-block" id="cut_remainder_fft_size_multiple"><a class="viewcode-back" href="../lib_fx_stack.html#lib_fx_stack.cut_remainder_fft_size_multiple">[docs]</a><span class="k">def</span> <span class="nf">cut_remainder_fft_size_multiple</span><span class="p">(</span><span class="n">F_partial</span><span class="p">,</span><span class="n">fft_size_multiple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to migrate functionality from np arrays to list of arrays (for delay correction...).</span>
<span class="sd">    It divides an array into two, one of them with rows of length fft_size_multiple, the other with the remainder.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     F_partial : list of numpy arrays</span>
<span class="sd">         samples in the time domain, with no rotation applied yet, and wherein each of its elements may have a different length.</span>
<span class="sd">     fft_size_multiple : int</span>
<span class="sd">         maximum integer multiple of fft_size that is lesser than the length of the shortest element of F_partial.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     F_partial_out</span>
<span class="sd">         F_partial (input) truncated to the ff_size_multiple first elements.</span>
<span class="sd">     F_partial_rem</span>
<span class="sd">         Remainder of removing F_partial_out from F_partial.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">F_partial_rem</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">F_partial_out</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">F_partial</span><span class="p">)):</span>
        <span class="n">F_partial_rem</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">F_partial</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:</span><span class="n">fft_size_multiple</span><span class="p">]))</span>
        <span class="n">F_partial_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">F_partial</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">fft_size_multiple</span><span class="p">:]))</span>
    <span class="k">return</span><span class="p">([</span><span class="n">F_partial_out</span><span class="p">,</span><span class="n">F_partial_rem</span><span class="p">])</span></div>


<div class="viewcode-block" id="compute_fx_for_all"><a class="viewcode-back" href="../lib_fx_stack.html#lib_fx_stack.compute_fx_for_all">[docs]</a><span class="k">def</span> <span class="nf">compute_fx_for_all</span><span class="p">(</span><span class="n">F1_partial</span><span class="p">,</span><span class="n">F_ind_partial</span><span class="p">,</span><span class="n">F1</span><span class="p">,</span><span class="n">fft_size</span><span class="p">,</span><span class="n">windowing</span><span class="p">,</span><span class="n">acc_mat</span><span class="p">,</span><span class="n">count_acc</span><span class="p">,</span><span class="n">normalize_after_compute</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">F_ind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>\
                       <span class="n">last_F_ind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">n_sp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">failed_acc_count</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">dismissed_acc_count</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">scaling_pair</span><span class="o">=</span><span class="s2">&quot;A.A&quot;</span><span class="p">,</span><span class="n">dtype_complex</span><span class="o">=</span><span class="nb">complex</span><span class="p">,</span>\
                       <span class="n">acc_pcal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">pre_pcal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">n_bins_pcal</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">count_acc_pcal</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">phase_calibration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>\
                       <span class="n">bypass_fx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">F_delays</span><span class="o">=</span><span class="p">[],</span><span class="n">F_rates</span><span class="o">=</span><span class="p">[],</span><span class="n">F_fs</span><span class="o">=</span><span class="p">[],</span><span class="n">freq_channel</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">F_first_sample</span><span class="o">=</span><span class="p">[],</span><span class="n">F_first_sample_partial</span><span class="o">=</span><span class="p">[],</span>\
                       <span class="n">F_frac</span><span class="o">=</span><span class="p">[],</span><span class="n">block_time</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">F_adj_shift_partial</span><span class="o">=</span><span class="p">[],</span><span class="n">F_stack_shift</span><span class="o">=</span><span class="p">[],</span><span class="n">F_adj_shift_pcal</span><span class="o">=</span><span class="p">[],</span><span class="n">F_stack_shift_pcal</span><span class="o">=</span><span class="p">[],</span>\
                       <span class="n">F_pcal_fix</span><span class="o">=</span><span class="p">[],</span><span class="n">F_side</span><span class="o">=</span><span class="p">[],</span><span class="n">F_lti</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fringe rotation, FFTs, fractional sample correction for all station-polarizations, and </span>
<span class="sd">         cross multiplication and accumulation for all baseline (all-baselines-per-task-mode)</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">     F1_partial</span>
<span class="sd">         list of previously stored samples.</span>
<span class="sd">     F_ind_partial</span>
<span class="sd">         station-polarization identifiers for the elements of F1_partial.</span>
<span class="sd">     F1</span>
<span class="sd">         new samples.</span>
<span class="sd">     fft_size</span>
<span class="sd">         number of coefficients fo the FFT.</span>
<span class="sd">     windowing</span>
<span class="sd">         shape of window prior to FFT (square by default).</span>
<span class="sd">     acc_mat</span>
<span class="sd">         accumulation matrix with provisional results (see compute_x_all for acc_mat description).</span>
<span class="sd">     count_acc</span>
<span class="sd">         number of accumulations performed so far.</span>
<span class="sd">     normalize_after_compute</span>
<span class="sd">         whether or not to normalize the results (to be activated in the last call in the integration period).</span>
<span class="sd">     F_ind</span>
<span class="sd">         station-polarization identifiers for the elements of F1.</span>
<span class="sd">     last_F_ind</span>
<span class="sd">         saved value of F_ind in the previous iteration.</span>
<span class="sd">     n_sp</span>
<span class="sd">         number of station-polarizations.</span>
<span class="sd">     failed_acc_count</span>
<span class="sd">         counter with number of failed accumulations. </span>
<span class="sd">     dismissed_acc_count</span>
<span class="sd">         counter with number of dismissed accumulations.</span>
<span class="sd">     scaling_pair</span>
<span class="sd">         mode of operation: &quot;A.A&quot; for all-baselines-per-task (default).</span>
<span class="sd">     dtype_complex</span>
<span class="sd">         complex type used for initialization of numpy arrays.</span>
<span class="sd">     acc_pcal</span>
<span class="sd">         provisional results for accumulated phase calibration.</span>
<span class="sd">     pre_pcal</span>
<span class="sd">         stored samples to be used in accumulation of phase calibration.</span>
<span class="sd">     n_bins_pcal</span>
<span class="sd">         number of samples for the windows to be accumulated for the pcal signal.</span>
<span class="sd">     count_acc</span>
<span class="sd">         number of accumulations performed previously during this integration period.</span>
<span class="sd">     phase_calibration</span>
<span class="sd">         whether or not to extract phase calibration tones.</span>
<span class="sd">     bypass_fx</span>
<span class="sd">         if 1, it will not do computations for cross-multiplication and accumulation.</span>
<span class="sd">     F_delays</span>
<span class="sd">         [unused] absolute delays for each of the streams in F1.</span>
<span class="sd">     F_rates</span>
<span class="sd">         delay information for each of the streams in F1.</span>
<span class="sd">     F_fs</span>
<span class="sd">         sampling frequency for each of the streams in F1.</span>
<span class="sd">     freq_channel</span>
<span class="sd">         sky frequency.</span>
<span class="sd">     F_first_sample</span>
<span class="sd">         first sample for each of the streams in F1.</span>
<span class="sd">     F_first_sample_partial</span>
<span class="sd">         first sample for each of the streams in the stored samples.</span>
<span class="sd">     F_frac</span>
<span class="sd">         fractional and integer sample delay for each of the streams in F1.</span>
<span class="sd">     block_time</span>
<span class="sd">         time for the current accumulation period.</span>
<span class="sd">     F_adj_shift_partial</span>
<span class="sd">         [unused] previously used to keep track of the samples to add/drop due to fractional sample </span>
<span class="sd">             correction overflow (now using F_frac_over).</span>
<span class="sd">     F_stack_shift</span>
<span class="sd">         [unused] previously used to keep track of the samples added/droped due to fractional sample </span>
<span class="sd">              correction (now using F_frac_over).</span>
<span class="sd">     F_adj_shift_pcal</span>
<span class="sd">         [unused] previously used to keep track of the samples to roll in the pcal signal.</span>
<span class="sd">     F_stack_shift_pcal</span>
<span class="sd">         [unused] equivalent to F_stack_shift for pcal.</span>
<span class="sd">     F_pcal_fix</span>
<span class="sd">         number of samples to roll in the pcal accumuled signal.</span>
<span class="sd">     F_side</span>
<span class="sd">         single side band side corresponding to the streams in F1.</span>
<span class="sd">     F_lti</span>
<span class="sd">         list of last, total, invalid samples for each stream</span>
<span class="sd">     </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     All output variables are udpated versions of those use as input, see procedure below for details.</span>
<span class="sd">     | acc_mat</span>
<span class="sd">     | count_acc</span>
<span class="sd">     | count_sub_acc</span>
<span class="sd">     | n_sp</span>
<span class="sd">     | last_F_ind</span>
<span class="sd">     | failed_acc_count</span>
<span class="sd">     | dismissed_acc_count</span>
<span class="sd">     | F1_partial</span>
<span class="sd">     | F_ind_partial</span>
<span class="sd">     | acc_pcal</span>
<span class="sd">     | pre_pcal</span>
<span class="sd">     | count_acc_pcal</span>
<span class="sd">     | F_first_sample_partial</span>
<span class="sd">     | F_adj_shift_partial</span>
<span class="sd">     | F_stack_shift</span>
<span class="sd">     | F_adj_shift_pcal</span>
<span class="sd">     | F_stack_shift_pcal</span>
<span class="sd">     | F_pcal_fix_out</span>
<span class="sd">     | F_lti</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    |</span>
<span class="sd">    | **Procedure:**</span>
<span class="sd">    |</span>
<span class="sd">    | All-stations-per-tasks:</span>
<span class="sd">    |  1. Concatenate samples (list of np arrays) for phase calibration computations.</span>
<span class="sd">    |  2. Check for overflow in fractional sample correction in new samples.</span>
<span class="sd">    |  3. Correct overflow in fractional sample correction (adding/dropping the required samples) in new samples.</span>
<span class="sd">    |  4. Concatenate new samples into stored samples.</span>
<span class="sd">    |  5. If possible separate the stored samples into two parts: the first part with a number of samples that is a multiple</span>
<span class="sd">    |        of the fft size, and the remained in the second part.</span>
<span class="sd">    |  6.  Correct fringe rotation, FFT, correct fractional sample delay and cross-multiply, results go to accumulation matrix.</span>
<span class="sd">    |  7. Leave unprocessed samples in F1_partial (stored samples).</span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **Conventions:**</span>
<span class="sd">    |</span>
<span class="sd">    | failed accumulation: an accumulation is considered failed if the elements for the new samples do not match those stored.</span>
<span class="sd">    | dismissed accumulation: an accumulation is considered dismissed if it is not computed becaused there are not enough samples.</span>
<span class="sd">    | variables ending in *_partial correspond to stored samples.</span>
<span class="sd">    | F_refs is used to point to new samples when iterating through stored samples. Note that F1, F_frac, so e.g. </span>
<span class="sd">    |        F_ind[F_refs[i]]==F_ind_partial[i] for i in range(F_ind_partial).</span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **Configuration for trade-off performance vs. memory requirements:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Use the variable COMPUTE_FOR_SUB_ACC_PERIOD in const_mapred.py to configure the number of times the new samples are simply</span>
<span class="sd">    |     stored without further computation. E.g. if =100, computations will be by-passed 99 out 100 times before the end </span>
<span class="sd">    |     of the integration period. This allows to take advantage of increased efficiency with long numpy arrays, and also</span>
<span class="sd">    |     to avoid some repeated computations in fringe_rotation() and compute_f_all().</span>
<span class="sd">    | </span>
<span class="sd">    |</span>
<span class="sd">    | **Limitations:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Curently number of bins for pcal has to be the same for all stations.</span>
<span class="sd">    |</span>
<span class="sd">    |</span>
<span class="sd">    | **TO DO:**</span>
<span class="sd">    |</span>
<span class="sd">    |  Add support for different numbers of bins?</span>
<span class="sd">    |  Check  if not(not_enough_data):, may be problematic with samples left out.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#if phase_calibration==0:</span>
    <span class="c1">#    phase_calibration=None</span>
    
    <span class="n">F_pcal_fix_out</span><span class="o">=</span><span class="p">[]</span>
    <span class="c1">#if F_first_sample_partial==[]:</span>
    <span class="c1">#    F_first_sample_partial=F_first_sample[:]</span>
    
    <span class="c1">#new_records=len(F_first_sample)-len(F_first_sample_partial)</span>
    <span class="c1">#if new_records&gt;0:</span>
    <span class="c1">#    for i in range(new_records</span>
        

    <span class="c1"># TO DO: this assumes that if more records are received, then none processing has been done, and therefore the first sample is still zero for all streams </span>
    <span class="c1"># TO DO: Check this</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">F_first_sample_partial</span><span class="p">)</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">F_first_sample</span><span class="p">):</span>
        <span class="c1">#F_first_sample_partial=[0]*len(F_first_sample)</span>
        <span class="n">F_first_sample_partial</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">F_first_sample</span><span class="p">)</span>
    


    <span class="k">if</span> <span class="n">DEBUG_DELAYS</span> <span class="ow">or</span> <span class="n">DEBUG_LIB_DELAY</span><span class="p">:</span> <span class="c1"># or DEBUG_FRAC_OVER :</span>
        <span class="k">if</span> <span class="n">F1</span><span class="o">!=</span><span class="p">[]:</span>
            <span class="n">n_max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span><span class="n">F1</span><span class="p">))</span>
            <span class="n">n_min</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span><span class="n">F1</span><span class="p">))</span>
            <span class="n">n_delta</span><span class="o">=</span><span class="n">n_max</span><span class="o">-</span><span class="n">n_min</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zR&quot;</span><span class="o">+</span><span class="n">KEY_SEP</span><span class="o">+</span><span class="s2">&quot;pre-hsp: stpols &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">F_ind_partial</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; with &quot;</span><span class="o">+</span>\
              <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span><span class="n">F1</span><span class="p">)))</span><span class="o">+</span><span class="s2">&quot; samples, delta_n is  &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n_delta</span><span class="p">))</span>

    <span class="n">count_sub_acc</span><span class="o">=</span><span class="mi">0</span>
    
    <span class="c1"># will reset F1 and F_ind at the end</span>
    <span class="n">reset_inputs</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">reset_pcal</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">F1_partial_rem</span><span class="o">=</span><span class="kc">None</span>
    <span class="n">pre_pcal_rem</span><span class="o">=</span><span class="kc">None</span>

    <span class="n">not_enough_data</span><span class="o">=</span><span class="mi">0</span>

    <span class="k">if</span> <span class="n">last_F_ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">last_F_ind</span><span class="p">)</span><span class="o">&gt;</span><span class="nb">len</span><span class="p">(</span><span class="n">F_ind</span><span class="p">):</span>
            <span class="c1"># TO DO: check if it&#39;s possible to still do computations for stored samples</span>
            <span class="c1"># Data not available for all stations (probably due to these being the last samples after alignment, will discard them)</span>
            <span class="n">dismissed_acc_count</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">not_enough_data</span><span class="o">=</span><span class="mi">1</span>

    <span class="c1"># TO DO: allow to pass for last iteration, but do not include new samples?</span>

    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">not_enough_data</span><span class="p">):</span>


        <span class="c1"># Stack samples from (F1_partial and F1)</span>
        <span class="c1">#if phase_calibration is not None:</span>
        <span class="k">if</span> <span class="n">phase_calibration</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Do not drop/add samples for phase calibration</span>
            <span class="c1"># TO DO: currently updated based on clock model (?)</span>
            <span class="p">[</span><span class="n">pre_pcal</span><span class="p">,</span><span class="n">F_ind_unused</span><span class="p">,</span><span class="n">F_refs</span><span class="p">,</span><span class="n">F_stack_shift_pcal</span><span class="p">,</span><span class="n">F_lti_unused</span><span class="p">,</span><span class="n">F_unused</span><span class="p">]</span><span class="o">=</span><span class="n">hstack_new_samples</span><span class="p">(</span><span class="n">pre_pcal</span><span class="p">,</span><span class="n">F_ind_partial</span><span class="p">,</span>\
                                                    <span class="n">F_ind</span><span class="p">,</span><span class="n">F1</span><span class="p">,</span><span class="n">F_adj_shift_pcal</span><span class="p">,</span><span class="n">F_stack_shift_pcal</span><span class="p">,</span><span class="n">F_lti</span><span class="p">,</span><span class="n">F_first_sample</span><span class="p">,</span><span class="s2">&quot;pcal&quot;</span><span class="p">,[])</span>
        
        <span class="c1"># Note:</span>
        <span class="c1">#  F_first_sample is for F1 (new samples)</span>
        <span class="c1">#  F_first_sample for F1_partial (stored samples)</span>
        <span class="c1"># Get locations of samples to be added/dropped (updates in fractional sample correction)</span>
        <span class="n">F_frac_over_ind</span><span class="o">=</span><span class="n">get_frac_over_ind</span><span class="p">(</span><span class="n">F_first_sample</span><span class="p">,</span><span class="n">F1</span><span class="p">,</span><span class="n">F_rates</span><span class="p">,</span><span class="n">F_fs</span><span class="p">,</span><span class="n">F_ind</span><span class="p">,</span><span class="n">F_side</span><span class="p">)</span>
        
        <span class="c1"># Apply changes to new data</span>
        <span class="n">F1</span><span class="o">=</span><span class="n">fix_frac_over</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span><span class="n">F_frac_over_ind</span><span class="p">,</span><span class="n">F_ind</span><span class="p">,</span><span class="n">F_first_sample</span><span class="p">)</span>
        
        <span class="c1"># Store new data on previous structures, relocating based on previous ordering</span>
        <span class="p">[</span><span class="n">F1_partial</span><span class="p">,</span><span class="n">F_ind_partial</span><span class="p">,</span><span class="n">F_refs</span><span class="p">,</span><span class="n">F_stack_shift</span><span class="p">,</span><span class="n">F_lti</span><span class="p">,</span><span class="n">F1</span><span class="p">]</span><span class="o">=</span><span class="n">hstack_new_samples</span><span class="p">(</span><span class="n">F1_partial</span><span class="p">,</span><span class="n">F_ind_partial</span><span class="p">,</span><span class="n">F_ind</span><span class="p">,</span><span class="n">F1</span><span class="p">,</span>\
                                                <span class="n">F_adj_shift_partial</span><span class="p">,</span><span class="n">F_stack_shift</span><span class="p">,</span><span class="n">F_lti</span><span class="p">,</span><span class="n">F_first_sample</span><span class="p">,</span><span class="s2">&quot;f&quot;</span><span class="p">,</span><span class="n">F_frac_over_ind</span><span class="p">)</span>
        
 
        <span class="n">index_scaling_pair</span><span class="o">=-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">scaling_pair</span><span class="o">!=</span><span class="s2">&quot;A.A&quot;</span><span class="p">:</span>
            <span class="c1"># Linear scaling stations</span>
            <span class="n">index_scaling_pair</span><span class="o">=</span><span class="n">F_ind</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">scaling_pair</span><span class="p">)</span>
        
        <span class="c1">#if (last_F_ind is None)or(last_F_ind==F_ind):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">last_F_ind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span><span class="ow">or</span><span class="p">(</span><span class="n">last_F_ind</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="o">==</span><span class="n">F_ind_partial</span><span class="o">.</span><span class="n">sort</span><span class="p">()):</span>
            <span class="c1">#last_F_ind=F_ind</span>
            <span class="n">last_F_ind</span><span class="o">=</span><span class="n">F_ind_partial</span><span class="p">[:]</span>
            
            
            <span class="c1"># pcal first</span>
            <span class="k">if</span> <span class="n">bypass_fx</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="c1">#if phase_calibration is not None:</span>
                <span class="k">if</span> <span class="n">phase_calibration</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    
                    <span class="p">[</span><span class="n">shortest_row_pre_pcal</span><span class="p">,</span><span class="n">longest_row_pre_pcal</span><span class="p">]</span> <span class="o">=</span> <span class="n">shortest_row_F</span><span class="p">(</span><span class="n">pre_pcal</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">shortest_row_pre_pcal</span><span class="o">&gt;=</span><span class="n">n_bins_pcal</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">longest_row_pre_pcal</span><span class="o">&gt;</span><span class="n">n_bins_pcal</span><span class="p">:</span>
                            <span class="n">pcal_size_multiple</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">shortest_row_pre_pcal</span><span class="o">//</span><span class="n">n_bins_pcal</span><span class="p">)</span><span class="o">*</span><span class="n">n_bins_pcal</span><span class="p">)</span>
                            <span class="p">[</span><span class="n">pre_pcal</span><span class="p">,</span><span class="n">pre_pcal_rem</span><span class="p">]</span><span class="o">=</span><span class="n">cut_remainder_fft_size_multiple</span><span class="p">(</span><span class="n">pre_pcal</span><span class="p">,</span><span class="n">pcal_size_multiple</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">pre_pcal_rem</span><span class="o">=</span><span class="kc">None</span>
                        <span class="n">count_acc_pcal</span><span class="o">+=</span><span class="nb">int</span><span class="p">(</span><span class="n">shortest_row_pre_pcal</span><span class="o">//</span><span class="n">n_bins_pcal</span><span class="p">)</span>
                        <span class="n">acc_pcal</span> <span class="o">=</span> <span class="n">accumulate_pcal_all</span><span class="p">(</span><span class="n">acc_pcal</span><span class="p">,</span><span class="n">pre_pcal</span><span class="p">,</span><span class="n">n_bins_pcal</span><span class="p">)</span>
                        <span class="n">reset_pcal</span><span class="o">=</span><span class="mi">1</span>
             
            <span class="k">if</span> <span class="n">bypass_fx</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                
                
                <span class="k">if</span> <span class="n">DEBUG_DELAYS</span>  <span class="ow">or</span> <span class="n">DEBUG_LIB_DELAY</span><span class="p">:</span> <span class="c1">#or DEBUG_FRAC_OVER:</span>
                    <span class="n">n_max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span><span class="n">F1_partial</span><span class="p">))</span>
                    <span class="n">n_min</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span><span class="n">F1_partial</span><span class="p">))</span>
                    <span class="n">n_delta</span><span class="o">=</span><span class="n">n_max</span><span class="o">-</span><span class="n">n_min</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zR&quot;</span><span class="o">+</span><span class="n">KEY_SEP</span><span class="o">+</span><span class="s2">&quot;hsp: stpols &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">F_ind_partial</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; with &quot;</span><span class="o">+</span>\
                      <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span><span class="n">F1_partial</span><span class="p">)))</span><span class="o">+</span><span class="s2">&quot; samples, delta_n is  &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n_delta</span><span class="p">))</span>
                
                <span class="p">[</span><span class="n">shortest_row_F1_partial</span><span class="p">,</span><span class="n">longest_row_F1_partial</span><span class="p">]</span> <span class="o">=</span> <span class="n">shortest_row_F</span><span class="p">(</span><span class="n">F1_partial</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">shortest_row_F1_partial</span><span class="o">&gt;=</span><span class="n">fft_size</span><span class="p">:</span>
                    <span class="c1"># Enough samples to do the processing            </span>
                    <span class="n">fft_size_multiple</span><span class="o">=</span><span class="mi">1</span>
                    <span class="k">if</span> <span class="n">longest_row_F1_partial</span><span class="o">&gt;</span><span class="n">fft_size</span><span class="p">:</span>
                        <span class="c1"># Too many samples, save for next acc block</span>
                        <span class="n">fft_size_multiple</span><span class="o">=</span><span class="nb">int</span><span class="p">((</span><span class="n">shortest_row_F1_partial</span><span class="o">//</span><span class="n">fft_size</span><span class="p">)</span><span class="o">*</span><span class="n">fft_size</span><span class="p">)</span>
                        <span class="p">[</span><span class="n">F1_partial</span><span class="p">,</span><span class="n">F1_partial_rem</span><span class="p">]</span><span class="o">=</span><span class="n">cut_remainder_fft_size_multiple</span><span class="p">(</span><span class="n">F1_partial</span><span class="p">,</span><span class="n">fft_size_multiple</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">F1_partial_rem</span><span class="o">=</span><span class="kc">None</span>
                    
                    <span class="k">if</span> <span class="n">fft_size_multiple</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        
                        <span class="p">[</span><span class="n">F1_partial</span><span class="p">,</span><span class="n">F_first_sample_partial</span><span class="p">]</span> <span class="o">=</span> <span class="n">fringe_rotation</span><span class="p">(</span><span class="n">F1_partial</span><span class="p">,</span><span class="n">F_first_sample_partial</span><span class="p">,</span>\
                                                       <span class="n">F_rates</span><span class="p">,</span><span class="n">freq_channel</span><span class="p">,</span><span class="n">F_fs</span><span class="p">,</span><span class="n">F_delays</span><span class="p">,</span><span class="n">F_refs</span><span class="p">,</span><span class="n">block_time</span><span class="p">,</span><span class="n">F_frac</span><span class="p">,</span>\
                                                       <span class="n">F_adj_shift_partial</span><span class="p">,</span><span class="n">F_side</span><span class="p">,</span><span class="n">F_ind_partial</span><span class="p">,</span><span class="n">F_lti</span><span class="p">)</span>

                        <span class="c1"># This includes corrections in frequency domain (fractional sample...)</span>
                        <span class="p">[</span><span class="n">F1_fft</span><span class="p">,</span><span class="n">F2_fft</span><span class="p">,</span><span class="n">F_adj_shift_partial</span><span class="p">,</span><span class="n">F_adj_shift_pcal</span><span class="p">,</span>\
                                    <span class="n">F_pcal_fix_out</span><span class="p">,</span><span class="n">F_first_sample_partial</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_f_all</span><span class="p">(</span><span class="n">F1_partial</span><span class="p">,</span><span class="n">fft_size</span><span class="p">,</span><span class="n">windowing</span><span class="p">,</span>\
                                                                         <span class="n">dtype_complex</span><span class="p">,</span><span class="n">F_frac</span><span class="p">,</span><span class="n">F_fs</span><span class="p">,</span>\
                                                                      <span class="n">F_refs</span><span class="p">,</span><span class="n">freq_channel</span><span class="p">,</span><span class="n">F_first_sample_partial</span><span class="p">,</span><span class="n">F_rates</span><span class="p">,</span>\
                                                                      <span class="n">F_pcal_fix</span><span class="p">,</span><span class="n">F_side</span><span class="p">,</span><span class="n">F_ind_partial</span><span class="p">,</span><span class="n">F_lti</span><span class="p">)</span>
                        
                        <span class="p">[</span><span class="n">acc_mat</span><span class="p">,</span><span class="n">count_acc</span><span class="p">,</span><span class="n">count_sub_acc</span><span class="p">,</span><span class="n">n_sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_x_all</span><span class="p">(</span><span class="n">F1_fft</span><span class="p">,</span><span class="n">F2_fft</span><span class="p">,</span><span class="n">count_acc</span><span class="p">,</span><span class="n">acc_mat</span><span class="p">,</span>\
                                                                    <span class="n">index_scaling_pair</span><span class="p">,</span><span class="n">dtype_complex</span><span class="p">)</span>

                        <span class="n">reset_inputs</span><span class="o">=</span><span class="mi">1</span>

                        <span class="c1">#    #TO DO?: resort if necessary based on F_ind and F_ind_partial...</span>
                
        <span class="k">else</span><span class="p">:</span>
            <span class="n">failed_acc_count</span><span class="o">+=</span><span class="mi">1</span>
        
        <span class="c1">#if normalize_after_compute:</span>
        <span class="c1">#    acc_mat = normalize_mat(acc_mat,count_acc)</span>
            
        <span class="k">if</span> <span class="n">reset_pcal</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pre_pcal_rem</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pre_pcal</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pre_pcal</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">pre_pcal_rem</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">reset_inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">F1_partial_rem</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">F1_partial</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
                <span class="c1">#F_ind_partial=[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">F1_partial</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">F1_partial_rem</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">normalize_after_compute</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">acc_mat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">acc_mat</span> <span class="o">=</span> <span class="n">normalize_mat</span><span class="p">(</span><span class="n">acc_mat</span><span class="p">,</span><span class="n">count_acc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">failed_acc_count</span><span class="o">+=</span><span class="mi">1</span>


    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">F_pcal_fix</span><span class="p">)</span><span class="o">&gt;=</span><span class="nb">len</span><span class="p">(</span><span class="n">F_pcal_fix_out</span><span class="p">)):</span>
        <span class="n">F_pcal_fix_out</span><span class="o">=</span><span class="n">F_pcal_fix</span> <span class="c1">#[:]</span>

    <span class="k">return</span><span class="p">([</span><span class="n">acc_mat</span><span class="p">,</span><span class="n">count_acc</span><span class="p">,</span><span class="n">count_sub_acc</span><span class="p">,</span><span class="n">n_sp</span><span class="p">,</span><span class="n">last_F_ind</span><span class="p">,</span><span class="n">failed_acc_count</span><span class="p">,</span><span class="n">dismissed_acc_count</span><span class="p">,</span><span class="n">F1_partial</span><span class="p">,</span><span class="n">F_ind_partial</span><span class="p">,</span><span class="n">acc_pcal</span><span class="p">,</span><span class="n">pre_pcal</span><span class="p">,</span><span class="n">count_acc_pcal</span><span class="p">,</span><span class="n">F_first_sample_partial</span><span class="p">,</span><span class="n">F_adj_shift_partial</span><span class="p">,</span><span class="n">F_stack_shift</span><span class="p">,</span><span class="n">F_adj_shift_pcal</span><span class="p">,</span><span class="n">F_stack_shift_pcal</span><span class="p">,</span><span class="n">F_pcal_fix_out</span><span class="p">,</span><span class="n">F_lti</span><span class="p">])</span></div>
                    
    
    

<span class="c1"># &lt;codecell&gt;</span>


</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Antonio Vazquez Alvarez, Victor Pankratius, and Pedro Elosegui.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>